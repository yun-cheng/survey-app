// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'recover_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RecoverEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function() responseMapUploading,
    required TResult Function() audioMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Either<AudioFailure, Audio> failureOrResult)
        audioUploaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_AudioMapUploading value) audioMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_AudioUploaded value) audioUploaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecoverEventCopyWith<$Res> {
  factory $RecoverEventCopyWith(
          RecoverEvent value, $Res Function(RecoverEvent) then) =
      _$RecoverEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$RecoverEventCopyWithImpl<$Res> implements $RecoverEventCopyWith<$Res> {
  _$RecoverEventCopyWithImpl(this._value, this._then);

  final RecoverEvent _value;
  // ignore: unused_field
  final $Res Function(RecoverEvent) _then;
}

/// @nodoc
abstract class _$$_InitializedCopyWith<$Res> {
  factory _$$_InitializedCopyWith(
          _$_Initialized value, $Res Function(_$_Initialized) then) =
      __$$_InitializedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitializedCopyWithImpl<$Res>
    extends _$RecoverEventCopyWithImpl<$Res>
    implements _$$_InitializedCopyWith<$Res> {
  __$$_InitializedCopyWithImpl(
      _$_Initialized _value, $Res Function(_$_Initialized) _then)
      : super(_value, (v) => _then(v as _$_Initialized));

  @override
  _$_Initialized get _value => super._value as _$_Initialized;
}

/// @nodoc

class _$_Initialized implements _Initialized {
  const _$_Initialized();

  @override
  String toString() {
    return 'RecoverEvent.initialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function() responseMapUploading,
    required TResult Function() audioMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Either<AudioFailure, Audio> failureOrResult)
        audioUploaded,
  }) {
    return initialized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
  }) {
    return initialized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
    required TResult orElse(),
  }) {
    if (initialized != null) {
      return initialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_AudioMapUploading value) audioMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_AudioUploaded value) audioUploaded,
  }) {
    return initialized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
  }) {
    return initialized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
    required TResult orElse(),
  }) {
    if (initialized != null) {
      return initialized(this);
    }
    return orElse();
  }
}

abstract class _Initialized implements RecoverEvent {
  const factory _Initialized() = _$_Initialized;
}

/// @nodoc
abstract class _$$_ResponseMapUploadingCopyWith<$Res> {
  factory _$$_ResponseMapUploadingCopyWith(_$_ResponseMapUploading value,
          $Res Function(_$_ResponseMapUploading) then) =
      __$$_ResponseMapUploadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ResponseMapUploadingCopyWithImpl<$Res>
    extends _$RecoverEventCopyWithImpl<$Res>
    implements _$$_ResponseMapUploadingCopyWith<$Res> {
  __$$_ResponseMapUploadingCopyWithImpl(_$_ResponseMapUploading _value,
      $Res Function(_$_ResponseMapUploading) _then)
      : super(_value, (v) => _then(v as _$_ResponseMapUploading));

  @override
  _$_ResponseMapUploading get _value => super._value as _$_ResponseMapUploading;
}

/// @nodoc

class _$_ResponseMapUploading implements _ResponseMapUploading {
  const _$_ResponseMapUploading();

  @override
  String toString() {
    return 'RecoverEvent.responseMapUploading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ResponseMapUploading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function() responseMapUploading,
    required TResult Function() audioMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Either<AudioFailure, Audio> failureOrResult)
        audioUploaded,
  }) {
    return responseMapUploading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
  }) {
    return responseMapUploading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
    required TResult orElse(),
  }) {
    if (responseMapUploading != null) {
      return responseMapUploading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_AudioMapUploading value) audioMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_AudioUploaded value) audioUploaded,
  }) {
    return responseMapUploading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
  }) {
    return responseMapUploading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
    required TResult orElse(),
  }) {
    if (responseMapUploading != null) {
      return responseMapUploading(this);
    }
    return orElse();
  }
}

abstract class _ResponseMapUploading implements RecoverEvent {
  const factory _ResponseMapUploading() = _$_ResponseMapUploading;
}

/// @nodoc
abstract class _$$_AudioMapUploadingCopyWith<$Res> {
  factory _$$_AudioMapUploadingCopyWith(_$_AudioMapUploading value,
          $Res Function(_$_AudioMapUploading) then) =
      __$$_AudioMapUploadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AudioMapUploadingCopyWithImpl<$Res>
    extends _$RecoverEventCopyWithImpl<$Res>
    implements _$$_AudioMapUploadingCopyWith<$Res> {
  __$$_AudioMapUploadingCopyWithImpl(
      _$_AudioMapUploading _value, $Res Function(_$_AudioMapUploading) _then)
      : super(_value, (v) => _then(v as _$_AudioMapUploading));

  @override
  _$_AudioMapUploading get _value => super._value as _$_AudioMapUploading;
}

/// @nodoc

class _$_AudioMapUploading implements _AudioMapUploading {
  const _$_AudioMapUploading();

  @override
  String toString() {
    return 'RecoverEvent.audioMapUploading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AudioMapUploading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function() responseMapUploading,
    required TResult Function() audioMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Either<AudioFailure, Audio> failureOrResult)
        audioUploaded,
  }) {
    return audioMapUploading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
  }) {
    return audioMapUploading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
    required TResult orElse(),
  }) {
    if (audioMapUploading != null) {
      return audioMapUploading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_AudioMapUploading value) audioMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_AudioUploaded value) audioUploaded,
  }) {
    return audioMapUploading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
  }) {
    return audioMapUploading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
    required TResult orElse(),
  }) {
    if (audioMapUploading != null) {
      return audioMapUploading(this);
    }
    return orElse();
  }
}

abstract class _AudioMapUploading implements RecoverEvent {
  const factory _AudioMapUploading() = _$_AudioMapUploading;
}

/// @nodoc
abstract class _$$_ResponseUploadedCopyWith<$Res> {
  factory _$$_ResponseUploadedCopyWith(
          _$_ResponseUploaded value, $Res Function(_$_ResponseUploaded) then) =
      __$$_ResponseUploadedCopyWithImpl<$Res>;
  $Res call({Either<SurveyFailure, String> failureOrResult});
}

/// @nodoc
class __$$_ResponseUploadedCopyWithImpl<$Res>
    extends _$RecoverEventCopyWithImpl<$Res>
    implements _$$_ResponseUploadedCopyWith<$Res> {
  __$$_ResponseUploadedCopyWithImpl(
      _$_ResponseUploaded _value, $Res Function(_$_ResponseUploaded) _then)
      : super(_value, (v) => _then(v as _$_ResponseUploaded));

  @override
  _$_ResponseUploaded get _value => super._value as _$_ResponseUploaded;

  @override
  $Res call({
    Object? failureOrResult = freezed,
  }) {
    return _then(_$_ResponseUploaded(
      failureOrResult == freezed
          ? _value.failureOrResult
          : failureOrResult // ignore: cast_nullable_to_non_nullable
              as Either<SurveyFailure, String>,
    ));
  }
}

/// @nodoc

class _$_ResponseUploaded implements _ResponseUploaded {
  const _$_ResponseUploaded(this.failureOrResult);

  @override
  final Either<SurveyFailure, String> failureOrResult;

  @override
  String toString() {
    return 'RecoverEvent.responseUploaded(failureOrResult: $failureOrResult)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseUploaded &&
            const DeepCollectionEquality()
                .equals(other.failureOrResult, failureOrResult));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureOrResult));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseUploadedCopyWith<_$_ResponseUploaded> get copyWith =>
      __$$_ResponseUploadedCopyWithImpl<_$_ResponseUploaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function() responseMapUploading,
    required TResult Function() audioMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Either<AudioFailure, Audio> failureOrResult)
        audioUploaded,
  }) {
    return responseUploaded(failureOrResult);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
  }) {
    return responseUploaded?.call(failureOrResult);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
    required TResult orElse(),
  }) {
    if (responseUploaded != null) {
      return responseUploaded(failureOrResult);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_AudioMapUploading value) audioMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_AudioUploaded value) audioUploaded,
  }) {
    return responseUploaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
  }) {
    return responseUploaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
    required TResult orElse(),
  }) {
    if (responseUploaded != null) {
      return responseUploaded(this);
    }
    return orElse();
  }
}

abstract class _ResponseUploaded implements RecoverEvent {
  const factory _ResponseUploaded(
          final Either<SurveyFailure, String> failureOrResult) =
      _$_ResponseUploaded;

  Either<SurveyFailure, String> get failureOrResult =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ResponseUploadedCopyWith<_$_ResponseUploaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AudioUploadedCopyWith<$Res> {
  factory _$$_AudioUploadedCopyWith(
          _$_AudioUploaded value, $Res Function(_$_AudioUploaded) then) =
      __$$_AudioUploadedCopyWithImpl<$Res>;
  $Res call({Either<AudioFailure, Audio> failureOrResult});
}

/// @nodoc
class __$$_AudioUploadedCopyWithImpl<$Res>
    extends _$RecoverEventCopyWithImpl<$Res>
    implements _$$_AudioUploadedCopyWith<$Res> {
  __$$_AudioUploadedCopyWithImpl(
      _$_AudioUploaded _value, $Res Function(_$_AudioUploaded) _then)
      : super(_value, (v) => _then(v as _$_AudioUploaded));

  @override
  _$_AudioUploaded get _value => super._value as _$_AudioUploaded;

  @override
  $Res call({
    Object? failureOrResult = freezed,
  }) {
    return _then(_$_AudioUploaded(
      failureOrResult == freezed
          ? _value.failureOrResult
          : failureOrResult // ignore: cast_nullable_to_non_nullable
              as Either<AudioFailure, Audio>,
    ));
  }
}

/// @nodoc

class _$_AudioUploaded implements _AudioUploaded {
  const _$_AudioUploaded(this.failureOrResult);

  @override
  final Either<AudioFailure, Audio> failureOrResult;

  @override
  String toString() {
    return 'RecoverEvent.audioUploaded(failureOrResult: $failureOrResult)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AudioUploaded &&
            const DeepCollectionEquality()
                .equals(other.failureOrResult, failureOrResult));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureOrResult));

  @JsonKey(ignore: true)
  @override
  _$$_AudioUploadedCopyWith<_$_AudioUploaded> get copyWith =>
      __$$_AudioUploadedCopyWithImpl<_$_AudioUploaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function() responseMapUploading,
    required TResult Function() audioMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Either<AudioFailure, Audio> failureOrResult)
        audioUploaded,
  }) {
    return audioUploaded(failureOrResult);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
  }) {
    return audioUploaded?.call(failureOrResult);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function()? responseMapUploading,
    TResult Function()? audioMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Either<AudioFailure, Audio> failureOrResult)?
        audioUploaded,
    required TResult orElse(),
  }) {
    if (audioUploaded != null) {
      return audioUploaded(failureOrResult);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_AudioMapUploading value) audioMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_AudioUploaded value) audioUploaded,
  }) {
    return audioUploaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
  }) {
    return audioUploaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_AudioMapUploading value)? audioMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_AudioUploaded value)? audioUploaded,
    required TResult orElse(),
  }) {
    if (audioUploaded != null) {
      return audioUploaded(this);
    }
    return orElse();
  }
}

abstract class _AudioUploaded implements RecoverEvent {
  const factory _AudioUploaded(
      final Either<AudioFailure, Audio> failureOrResult) = _$_AudioUploaded;

  Either<AudioFailure, Audio> get failureOrResult =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_AudioUploadedCopyWith<_$_AudioUploaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RecoverState {
  UniqueId get stateId => throw _privateConstructorUsedError;
  Map<UniqueId, Response> get responseMap => throw _privateConstructorUsedError;
  Map<String, Map<String, dynamic>> get uploadResponseMap =>
      throw _privateConstructorUsedError;
  Set<String> get uploadedResponseIdSet => throw _privateConstructorUsedError;
  Set<String> get uploadFailedResponseIdSet =>
      throw _privateConstructorUsedError;
  Set<String> get audioIdSet => throw _privateConstructorUsedError;
  Set<String> get uploadedAudioIdSet => throw _privateConstructorUsedError;
  Set<String> get uploadFailedAudioIdSet => throw _privateConstructorUsedError;
  LoadState get eventState => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RecoverStateCopyWith<RecoverState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecoverStateCopyWith<$Res> {
  factory $RecoverStateCopyWith(
          RecoverState value, $Res Function(RecoverState) then) =
      _$RecoverStateCopyWithImpl<$Res>;
  $Res call(
      {UniqueId stateId,
      Map<UniqueId, Response> responseMap,
      Map<String, Map<String, dynamic>> uploadResponseMap,
      Set<String> uploadedResponseIdSet,
      Set<String> uploadFailedResponseIdSet,
      Set<String> audioIdSet,
      Set<String> uploadedAudioIdSet,
      Set<String> uploadFailedAudioIdSet,
      LoadState eventState});

  $UniqueIdCopyWith<$Res> get stateId;
  $LoadStateCopyWith<$Res> get eventState;
}

/// @nodoc
class _$RecoverStateCopyWithImpl<$Res> implements $RecoverStateCopyWith<$Res> {
  _$RecoverStateCopyWithImpl(this._value, this._then);

  final RecoverState _value;
  // ignore: unused_field
  final $Res Function(RecoverState) _then;

  @override
  $Res call({
    Object? stateId = freezed,
    Object? responseMap = freezed,
    Object? uploadResponseMap = freezed,
    Object? uploadedResponseIdSet = freezed,
    Object? uploadFailedResponseIdSet = freezed,
    Object? audioIdSet = freezed,
    Object? uploadedAudioIdSet = freezed,
    Object? uploadFailedAudioIdSet = freezed,
    Object? eventState = freezed,
  }) {
    return _then(_value.copyWith(
      stateId: stateId == freezed
          ? _value.stateId
          : stateId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      responseMap: responseMap == freezed
          ? _value.responseMap
          : responseMap // ignore: cast_nullable_to_non_nullable
              as Map<UniqueId, Response>,
      uploadResponseMap: uploadResponseMap == freezed
          ? _value.uploadResponseMap
          : uploadResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Map<String, dynamic>>,
      uploadedResponseIdSet: uploadedResponseIdSet == freezed
          ? _value.uploadedResponseIdSet
          : uploadedResponseIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      uploadFailedResponseIdSet: uploadFailedResponseIdSet == freezed
          ? _value.uploadFailedResponseIdSet
          : uploadFailedResponseIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      audioIdSet: audioIdSet == freezed
          ? _value.audioIdSet
          : audioIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      uploadedAudioIdSet: uploadedAudioIdSet == freezed
          ? _value.uploadedAudioIdSet
          : uploadedAudioIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      uploadFailedAudioIdSet: uploadFailedAudioIdSet == freezed
          ? _value.uploadFailedAudioIdSet
          : uploadFailedAudioIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      eventState: eventState == freezed
          ? _value.eventState
          : eventState // ignore: cast_nullable_to_non_nullable
              as LoadState,
    ));
  }

  @override
  $UniqueIdCopyWith<$Res> get stateId {
    return $UniqueIdCopyWith<$Res>(_value.stateId, (value) {
      return _then(_value.copyWith(stateId: value));
    });
  }

  @override
  $LoadStateCopyWith<$Res> get eventState {
    return $LoadStateCopyWith<$Res>(_value.eventState, (value) {
      return _then(_value.copyWith(eventState: value));
    });
  }
}

/// @nodoc
abstract class _$$_RecoverStateCopyWith<$Res>
    implements $RecoverStateCopyWith<$Res> {
  factory _$$_RecoverStateCopyWith(
          _$_RecoverState value, $Res Function(_$_RecoverState) then) =
      __$$_RecoverStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {UniqueId stateId,
      Map<UniqueId, Response> responseMap,
      Map<String, Map<String, dynamic>> uploadResponseMap,
      Set<String> uploadedResponseIdSet,
      Set<String> uploadFailedResponseIdSet,
      Set<String> audioIdSet,
      Set<String> uploadedAudioIdSet,
      Set<String> uploadFailedAudioIdSet,
      LoadState eventState});

  @override
  $UniqueIdCopyWith<$Res> get stateId;
  @override
  $LoadStateCopyWith<$Res> get eventState;
}

/// @nodoc
class __$$_RecoverStateCopyWithImpl<$Res>
    extends _$RecoverStateCopyWithImpl<$Res>
    implements _$$_RecoverStateCopyWith<$Res> {
  __$$_RecoverStateCopyWithImpl(
      _$_RecoverState _value, $Res Function(_$_RecoverState) _then)
      : super(_value, (v) => _then(v as _$_RecoverState));

  @override
  _$_RecoverState get _value => super._value as _$_RecoverState;

  @override
  $Res call({
    Object? stateId = freezed,
    Object? responseMap = freezed,
    Object? uploadResponseMap = freezed,
    Object? uploadedResponseIdSet = freezed,
    Object? uploadFailedResponseIdSet = freezed,
    Object? audioIdSet = freezed,
    Object? uploadedAudioIdSet = freezed,
    Object? uploadFailedAudioIdSet = freezed,
    Object? eventState = freezed,
  }) {
    return _then(_$_RecoverState(
      stateId: stateId == freezed
          ? _value.stateId
          : stateId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      responseMap: responseMap == freezed
          ? _value._responseMap
          : responseMap // ignore: cast_nullable_to_non_nullable
              as Map<UniqueId, Response>,
      uploadResponseMap: uploadResponseMap == freezed
          ? _value._uploadResponseMap
          : uploadResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Map<String, dynamic>>,
      uploadedResponseIdSet: uploadedResponseIdSet == freezed
          ? _value._uploadedResponseIdSet
          : uploadedResponseIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      uploadFailedResponseIdSet: uploadFailedResponseIdSet == freezed
          ? _value._uploadFailedResponseIdSet
          : uploadFailedResponseIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      audioIdSet: audioIdSet == freezed
          ? _value._audioIdSet
          : audioIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      uploadedAudioIdSet: uploadedAudioIdSet == freezed
          ? _value._uploadedAudioIdSet
          : uploadedAudioIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      uploadFailedAudioIdSet: uploadFailedAudioIdSet == freezed
          ? _value._uploadFailedAudioIdSet
          : uploadFailedAudioIdSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      eventState: eventState == freezed
          ? _value.eventState
          : eventState // ignore: cast_nullable_to_non_nullable
              as LoadState,
    ));
  }
}

/// @nodoc

class _$_RecoverState extends _RecoverState {
  const _$_RecoverState(
      {required this.stateId,
      required final Map<UniqueId, Response> responseMap,
      required final Map<String, Map<String, dynamic>> uploadResponseMap,
      required final Set<String> uploadedResponseIdSet,
      required final Set<String> uploadFailedResponseIdSet,
      required final Set<String> audioIdSet,
      required final Set<String> uploadedAudioIdSet,
      required final Set<String> uploadFailedAudioIdSet,
      required this.eventState})
      : _responseMap = responseMap,
        _uploadResponseMap = uploadResponseMap,
        _uploadedResponseIdSet = uploadedResponseIdSet,
        _uploadFailedResponseIdSet = uploadFailedResponseIdSet,
        _audioIdSet = audioIdSet,
        _uploadedAudioIdSet = uploadedAudioIdSet,
        _uploadFailedAudioIdSet = uploadFailedAudioIdSet,
        super._();

  @override
  final UniqueId stateId;
  final Map<UniqueId, Response> _responseMap;
  @override
  Map<UniqueId, Response> get responseMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_responseMap);
  }

  final Map<String, Map<String, dynamic>> _uploadResponseMap;
  @override
  Map<String, Map<String, dynamic>> get uploadResponseMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_uploadResponseMap);
  }

  final Set<String> _uploadedResponseIdSet;
  @override
  Set<String> get uploadedResponseIdSet {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_uploadedResponseIdSet);
  }

  final Set<String> _uploadFailedResponseIdSet;
  @override
  Set<String> get uploadFailedResponseIdSet {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_uploadFailedResponseIdSet);
  }

  final Set<String> _audioIdSet;
  @override
  Set<String> get audioIdSet {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_audioIdSet);
  }

  final Set<String> _uploadedAudioIdSet;
  @override
  Set<String> get uploadedAudioIdSet {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_uploadedAudioIdSet);
  }

  final Set<String> _uploadFailedAudioIdSet;
  @override
  Set<String> get uploadFailedAudioIdSet {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_uploadFailedAudioIdSet);
  }

  @override
  final LoadState eventState;

  @override
  String toString() {
    return 'RecoverState(stateId: $stateId, responseMap: $responseMap, uploadResponseMap: $uploadResponseMap, uploadedResponseIdSet: $uploadedResponseIdSet, uploadFailedResponseIdSet: $uploadFailedResponseIdSet, audioIdSet: $audioIdSet, uploadedAudioIdSet: $uploadedAudioIdSet, uploadFailedAudioIdSet: $uploadFailedAudioIdSet, eventState: $eventState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RecoverState &&
            const DeepCollectionEquality().equals(other.stateId, stateId) &&
            const DeepCollectionEquality()
                .equals(other._responseMap, _responseMap) &&
            const DeepCollectionEquality()
                .equals(other._uploadResponseMap, _uploadResponseMap) &&
            const DeepCollectionEquality()
                .equals(other._uploadedResponseIdSet, _uploadedResponseIdSet) &&
            const DeepCollectionEquality().equals(
                other._uploadFailedResponseIdSet, _uploadFailedResponseIdSet) &&
            const DeepCollectionEquality()
                .equals(other._audioIdSet, _audioIdSet) &&
            const DeepCollectionEquality()
                .equals(other._uploadedAudioIdSet, _uploadedAudioIdSet) &&
            const DeepCollectionEquality().equals(
                other._uploadFailedAudioIdSet, _uploadFailedAudioIdSet) &&
            const DeepCollectionEquality()
                .equals(other.eventState, eventState));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(stateId),
      const DeepCollectionEquality().hash(_responseMap),
      const DeepCollectionEquality().hash(_uploadResponseMap),
      const DeepCollectionEquality().hash(_uploadedResponseIdSet),
      const DeepCollectionEquality().hash(_uploadFailedResponseIdSet),
      const DeepCollectionEquality().hash(_audioIdSet),
      const DeepCollectionEquality().hash(_uploadedAudioIdSet),
      const DeepCollectionEquality().hash(_uploadFailedAudioIdSet),
      const DeepCollectionEquality().hash(eventState));

  @JsonKey(ignore: true)
  @override
  _$$_RecoverStateCopyWith<_$_RecoverState> get copyWith =>
      __$$_RecoverStateCopyWithImpl<_$_RecoverState>(this, _$identity);
}

abstract class _RecoverState extends RecoverState {
  const factory _RecoverState(
      {required final UniqueId stateId,
      required final Map<UniqueId, Response> responseMap,
      required final Map<String, Map<String, dynamic>> uploadResponseMap,
      required final Set<String> uploadedResponseIdSet,
      required final Set<String> uploadFailedResponseIdSet,
      required final Set<String> audioIdSet,
      required final Set<String> uploadedAudioIdSet,
      required final Set<String> uploadFailedAudioIdSet,
      required final LoadState eventState}) = _$_RecoverState;
  const _RecoverState._() : super._();

  @override
  UniqueId get stateId => throw _privateConstructorUsedError;
  @override
  Map<UniqueId, Response> get responseMap => throw _privateConstructorUsedError;
  @override
  Map<String, Map<String, dynamic>> get uploadResponseMap =>
      throw _privateConstructorUsedError;
  @override
  Set<String> get uploadedResponseIdSet => throw _privateConstructorUsedError;
  @override
  Set<String> get uploadFailedResponseIdSet =>
      throw _privateConstructorUsedError;
  @override
  Set<String> get audioIdSet => throw _privateConstructorUsedError;
  @override
  Set<String> get uploadedAudioIdSet => throw _privateConstructorUsedError;
  @override
  Set<String> get uploadFailedAudioIdSet => throw _privateConstructorUsedError;
  @override
  LoadState get eventState => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_RecoverStateCopyWith<_$_RecoverState> get copyWith =>
      throw _privateConstructorUsedError;
}
