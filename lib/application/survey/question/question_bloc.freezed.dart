// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'question_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$QuestionEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionEventCopyWith<$Res> {
  factory $QuestionEventCopyWith(
          QuestionEvent value, $Res Function(QuestionEvent) then) =
      _$QuestionEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$QuestionEventCopyWithImpl<$Res>
    implements $QuestionEventCopyWith<$Res> {
  _$QuestionEventCopyWithImpl(this._value, this._then);

  final QuestionEvent _value;
  // ignore: unused_field
  final $Res Function(QuestionEvent) _then;
}

/// @nodoc
abstract class _$$_ClearAnswerCopyWith<$Res> {
  factory _$$_ClearAnswerCopyWith(
          _$_ClearAnswer value, $Res Function(_$_ClearAnswer) then) =
      __$$_ClearAnswerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ClearAnswerCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res>
    implements _$$_ClearAnswerCopyWith<$Res> {
  __$$_ClearAnswerCopyWithImpl(
      _$_ClearAnswer _value, $Res Function(_$_ClearAnswer) _then)
      : super(_value, (v) => _then(v as _$_ClearAnswer));

  @override
  _$_ClearAnswer get _value => super._value as _$_ClearAnswer;
}

/// @nodoc

class _$_ClearAnswer implements _ClearAnswer {
  const _$_ClearAnswer();

  @override
  String toString() {
    return 'QuestionEvent.clearAnswer()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ClearAnswer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) {
    return clearAnswer();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) {
    return clearAnswer?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (clearAnswer != null) {
      return clearAnswer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) {
    return clearAnswer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) {
    return clearAnswer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (clearAnswer != null) {
      return clearAnswer(this);
    }
    return orElse();
  }
}

abstract class _ClearAnswer implements QuestionEvent {
  const factory _ClearAnswer() = _$_ClearAnswer;
}

/// @nodoc
abstract class _$$_SetChoiceCopyWith<$Res> {
  factory _$$_SetChoiceCopyWith(
          _$_SetChoice value, $Res Function(_$_SetChoice) then) =
      __$$_SetChoiceCopyWithImpl<$Res>;
  $Res call({Choice choice});

  $ChoiceCopyWith<$Res> get choice;
}

/// @nodoc
class __$$_SetChoiceCopyWithImpl<$Res> extends _$QuestionEventCopyWithImpl<$Res>
    implements _$$_SetChoiceCopyWith<$Res> {
  __$$_SetChoiceCopyWithImpl(
      _$_SetChoice _value, $Res Function(_$_SetChoice) _then)
      : super(_value, (v) => _then(v as _$_SetChoice));

  @override
  _$_SetChoice get _value => super._value as _$_SetChoice;

  @override
  $Res call({
    Object? choice = freezed,
  }) {
    return _then(_$_SetChoice(
      choice == freezed
          ? _value.choice
          : choice // ignore: cast_nullable_to_non_nullable
              as Choice,
    ));
  }

  @override
  $ChoiceCopyWith<$Res> get choice {
    return $ChoiceCopyWith<$Res>(_value.choice, (value) {
      return _then(_value.copyWith(choice: value));
    });
  }
}

/// @nodoc

class _$_SetChoice implements _SetChoice {
  const _$_SetChoice(this.choice);

  @override
  final Choice choice;

  @override
  String toString() {
    return 'QuestionEvent.setChoice(choice: $choice)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SetChoice &&
            const DeepCollectionEquality().equals(other.choice, choice));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(choice));

  @JsonKey(ignore: true)
  @override
  _$$_SetChoiceCopyWith<_$_SetChoice> get copyWith =>
      __$$_SetChoiceCopyWithImpl<_$_SetChoice>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) {
    return setChoice(choice);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) {
    return setChoice?.call(choice);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (setChoice != null) {
      return setChoice(choice);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) {
    return setChoice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) {
    return setChoice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (setChoice != null) {
      return setChoice(this);
    }
    return orElse();
  }
}

abstract class _SetChoice implements QuestionEvent {
  const factory _SetChoice(final Choice choice) = _$_SetChoice;

  Choice get choice => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_SetChoiceCopyWith<_$_SetChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ToggleChoiceCopyWith<$Res> {
  factory _$$_ToggleChoiceCopyWith(
          _$_ToggleChoice value, $Res Function(_$_ToggleChoice) then) =
      __$$_ToggleChoiceCopyWithImpl<$Res>;
  $Res call({Choice choice});

  $ChoiceCopyWith<$Res> get choice;
}

/// @nodoc
class __$$_ToggleChoiceCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res>
    implements _$$_ToggleChoiceCopyWith<$Res> {
  __$$_ToggleChoiceCopyWithImpl(
      _$_ToggleChoice _value, $Res Function(_$_ToggleChoice) _then)
      : super(_value, (v) => _then(v as _$_ToggleChoice));

  @override
  _$_ToggleChoice get _value => super._value as _$_ToggleChoice;

  @override
  $Res call({
    Object? choice = freezed,
  }) {
    return _then(_$_ToggleChoice(
      choice == freezed
          ? _value.choice
          : choice // ignore: cast_nullable_to_non_nullable
              as Choice,
    ));
  }

  @override
  $ChoiceCopyWith<$Res> get choice {
    return $ChoiceCopyWith<$Res>(_value.choice, (value) {
      return _then(_value.copyWith(choice: value));
    });
  }
}

/// @nodoc

class _$_ToggleChoice implements _ToggleChoice {
  const _$_ToggleChoice(this.choice);

  @override
  final Choice choice;

  @override
  String toString() {
    return 'QuestionEvent.toggleChoice(choice: $choice)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ToggleChoice &&
            const DeepCollectionEquality().equals(other.choice, choice));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(choice));

  @JsonKey(ignore: true)
  @override
  _$$_ToggleChoiceCopyWith<_$_ToggleChoice> get copyWith =>
      __$$_ToggleChoiceCopyWithImpl<_$_ToggleChoice>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) {
    return toggleChoice(choice);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) {
    return toggleChoice?.call(choice);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (toggleChoice != null) {
      return toggleChoice(choice);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) {
    return toggleChoice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) {
    return toggleChoice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (toggleChoice != null) {
      return toggleChoice(this);
    }
    return orElse();
  }
}

abstract class _ToggleChoice implements QuestionEvent {
  const factory _ToggleChoice(final Choice choice) = _$_ToggleChoice;

  Choice get choice => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ToggleChoiceCopyWith<_$_ToggleChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SetSpecialAnswerCopyWith<$Res> {
  factory _$$_SetSpecialAnswerCopyWith(
          _$_SetSpecialAnswer value, $Res Function(_$_SetSpecialAnswer) then) =
      __$$_SetSpecialAnswerCopyWithImpl<$Res>;
  $Res call({bool isSpecialAnswer});
}

/// @nodoc
class __$$_SetSpecialAnswerCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res>
    implements _$$_SetSpecialAnswerCopyWith<$Res> {
  __$$_SetSpecialAnswerCopyWithImpl(
      _$_SetSpecialAnswer _value, $Res Function(_$_SetSpecialAnswer) _then)
      : super(_value, (v) => _then(v as _$_SetSpecialAnswer));

  @override
  _$_SetSpecialAnswer get _value => super._value as _$_SetSpecialAnswer;

  @override
  $Res call({
    Object? isSpecialAnswer = freezed,
  }) {
    return _then(_$_SetSpecialAnswer(
      isSpecialAnswer == freezed
          ? _value.isSpecialAnswer
          : isSpecialAnswer // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_SetSpecialAnswer implements _SetSpecialAnswer {
  const _$_SetSpecialAnswer(this.isSpecialAnswer);

  @override
  final bool isSpecialAnswer;

  @override
  String toString() {
    return 'QuestionEvent.setSpecialAnswer(isSpecialAnswer: $isSpecialAnswer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SetSpecialAnswer &&
            const DeepCollectionEquality()
                .equals(other.isSpecialAnswer, isSpecialAnswer));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(isSpecialAnswer));

  @JsonKey(ignore: true)
  @override
  _$$_SetSpecialAnswerCopyWith<_$_SetSpecialAnswer> get copyWith =>
      __$$_SetSpecialAnswerCopyWithImpl<_$_SetSpecialAnswer>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) {
    return setSpecialAnswer(isSpecialAnswer);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) {
    return setSpecialAnswer?.call(isSpecialAnswer);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (setSpecialAnswer != null) {
      return setSpecialAnswer(isSpecialAnswer);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) {
    return setSpecialAnswer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) {
    return setSpecialAnswer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (setSpecialAnswer != null) {
      return setSpecialAnswer(this);
    }
    return orElse();
  }
}

abstract class _SetSpecialAnswer implements QuestionEvent {
  const factory _SetSpecialAnswer(final bool isSpecialAnswer) =
      _$_SetSpecialAnswer;

  bool get isSpecialAnswer => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_SetSpecialAnswerCopyWith<_$_SetSpecialAnswer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_QABoxShownCopyWith<$Res> {
  factory _$$_QABoxShownCopyWith(
          _$_QABoxShown value, $Res Function(_$_QABoxShown) then) =
      __$$_QABoxShownCopyWithImpl<$Res>;
  $Res call({bool value});
}

/// @nodoc
class __$$_QABoxShownCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res>
    implements _$$_QABoxShownCopyWith<$Res> {
  __$$_QABoxShownCopyWithImpl(
      _$_QABoxShown _value, $Res Function(_$_QABoxShown) _then)
      : super(_value, (v) => _then(v as _$_QABoxShown));

  @override
  _$_QABoxShown get _value => super._value as _$_QABoxShown;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_QABoxShown(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_QABoxShown implements _QABoxShown {
  const _$_QABoxShown(this.value);

  @override
  final bool value;

  @override
  String toString() {
    return 'QuestionEvent.qABoxShown(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QABoxShown &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_QABoxShownCopyWith<_$_QABoxShown> get copyWith =>
      __$$_QABoxShownCopyWithImpl<_$_QABoxShown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) {
    return qABoxShown(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) {
    return qABoxShown?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (qABoxShown != null) {
      return qABoxShown(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) {
    return qABoxShown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) {
    return qABoxShown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (qABoxShown != null) {
      return qABoxShown(this);
    }
    return orElse();
  }
}

abstract class _QABoxShown implements QuestionEvent {
  const factory _QABoxShown(final bool value) = _$_QABoxShown;

  bool get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_QABoxShownCopyWith<_$_QABoxShown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AnswerBoxShownCopyWith<$Res> {
  factory _$$_AnswerBoxShownCopyWith(
          _$_AnswerBoxShown value, $Res Function(_$_AnswerBoxShown) then) =
      __$$_AnswerBoxShownCopyWithImpl<$Res>;
  $Res call({bool value});
}

/// @nodoc
class __$$_AnswerBoxShownCopyWithImpl<$Res>
    extends _$QuestionEventCopyWithImpl<$Res>
    implements _$$_AnswerBoxShownCopyWith<$Res> {
  __$$_AnswerBoxShownCopyWithImpl(
      _$_AnswerBoxShown _value, $Res Function(_$_AnswerBoxShown) _then)
      : super(_value, (v) => _then(v as _$_AnswerBoxShown));

  @override
  _$_AnswerBoxShown get _value => super._value as _$_AnswerBoxShown;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_AnswerBoxShown(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_AnswerBoxShown implements _AnswerBoxShown {
  const _$_AnswerBoxShown(this.value);

  @override
  final bool value;

  @override
  String toString() {
    return 'QuestionEvent.answerBoxShown(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnswerBoxShown &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_AnswerBoxShownCopyWith<_$_AnswerBoxShown> get copyWith =>
      __$$_AnswerBoxShownCopyWithImpl<_$_AnswerBoxShown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clearAnswer,
    required TResult Function(Choice choice) setChoice,
    required TResult Function(Choice choice) toggleChoice,
    required TResult Function(bool isSpecialAnswer) setSpecialAnswer,
    required TResult Function(bool value) qABoxShown,
    required TResult Function(bool value) answerBoxShown,
  }) {
    return answerBoxShown(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
  }) {
    return answerBoxShown?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clearAnswer,
    TResult Function(Choice choice)? setChoice,
    TResult Function(Choice choice)? toggleChoice,
    TResult Function(bool isSpecialAnswer)? setSpecialAnswer,
    TResult Function(bool value)? qABoxShown,
    TResult Function(bool value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (answerBoxShown != null) {
      return answerBoxShown(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClearAnswer value) clearAnswer,
    required TResult Function(_SetChoice value) setChoice,
    required TResult Function(_ToggleChoice value) toggleChoice,
    required TResult Function(_SetSpecialAnswer value) setSpecialAnswer,
    required TResult Function(_QABoxShown value) qABoxShown,
    required TResult Function(_AnswerBoxShown value) answerBoxShown,
  }) {
    return answerBoxShown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
  }) {
    return answerBoxShown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClearAnswer value)? clearAnswer,
    TResult Function(_SetChoice value)? setChoice,
    TResult Function(_ToggleChoice value)? toggleChoice,
    TResult Function(_SetSpecialAnswer value)? setSpecialAnswer,
    TResult Function(_QABoxShown value)? qABoxShown,
    TResult Function(_AnswerBoxShown value)? answerBoxShown,
    required TResult orElse(),
  }) {
    if (answerBoxShown != null) {
      return answerBoxShown(this);
    }
    return orElse();
  }
}

abstract class _AnswerBoxShown implements QuestionEvent {
  const factory _AnswerBoxShown(final bool value) = _$_AnswerBoxShown;

  bool get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_AnswerBoxShownCopyWith<_$_AnswerBoxShown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$QuestionState {
  UniqueId get stateId => throw _privateConstructorUsedError;
  Question get question => throw _privateConstructorUsedError;
  Answer get answer => throw _privateConstructorUsedError;
  bool get isSpecialAnswer => throw _privateConstructorUsedError;
  bool get withinCell => throw _privateConstructorUsedError;
  bool get canEdit => throw _privateConstructorUsedError;
  bool get qABoxIsShown => throw _privateConstructorUsedError;
  bool get answerBoxIsShown => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $QuestionStateCopyWith<QuestionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionStateCopyWith<$Res> {
  factory $QuestionStateCopyWith(
          QuestionState value, $Res Function(QuestionState) then) =
      _$QuestionStateCopyWithImpl<$Res>;
  $Res call(
      {UniqueId stateId,
      Question question,
      Answer answer,
      bool isSpecialAnswer,
      bool withinCell,
      bool canEdit,
      bool qABoxIsShown,
      bool answerBoxIsShown});

  $UniqueIdCopyWith<$Res> get stateId;
  $QuestionCopyWith<$Res> get question;
  $AnswerCopyWith<$Res> get answer;
}

/// @nodoc
class _$QuestionStateCopyWithImpl<$Res>
    implements $QuestionStateCopyWith<$Res> {
  _$QuestionStateCopyWithImpl(this._value, this._then);

  final QuestionState _value;
  // ignore: unused_field
  final $Res Function(QuestionState) _then;

  @override
  $Res call({
    Object? stateId = freezed,
    Object? question = freezed,
    Object? answer = freezed,
    Object? isSpecialAnswer = freezed,
    Object? withinCell = freezed,
    Object? canEdit = freezed,
    Object? qABoxIsShown = freezed,
    Object? answerBoxIsShown = freezed,
  }) {
    return _then(_value.copyWith(
      stateId: stateId == freezed
          ? _value.stateId
          : stateId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      question: question == freezed
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as Question,
      answer: answer == freezed
          ? _value.answer
          : answer // ignore: cast_nullable_to_non_nullable
              as Answer,
      isSpecialAnswer: isSpecialAnswer == freezed
          ? _value.isSpecialAnswer
          : isSpecialAnswer // ignore: cast_nullable_to_non_nullable
              as bool,
      withinCell: withinCell == freezed
          ? _value.withinCell
          : withinCell // ignore: cast_nullable_to_non_nullable
              as bool,
      canEdit: canEdit == freezed
          ? _value.canEdit
          : canEdit // ignore: cast_nullable_to_non_nullable
              as bool,
      qABoxIsShown: qABoxIsShown == freezed
          ? _value.qABoxIsShown
          : qABoxIsShown // ignore: cast_nullable_to_non_nullable
              as bool,
      answerBoxIsShown: answerBoxIsShown == freezed
          ? _value.answerBoxIsShown
          : answerBoxIsShown // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  $UniqueIdCopyWith<$Res> get stateId {
    return $UniqueIdCopyWith<$Res>(_value.stateId, (value) {
      return _then(_value.copyWith(stateId: value));
    });
  }

  @override
  $QuestionCopyWith<$Res> get question {
    return $QuestionCopyWith<$Res>(_value.question, (value) {
      return _then(_value.copyWith(question: value));
    });
  }

  @override
  $AnswerCopyWith<$Res> get answer {
    return $AnswerCopyWith<$Res>(_value.answer, (value) {
      return _then(_value.copyWith(answer: value));
    });
  }
}

/// @nodoc
abstract class _$$_QuestionStateCopyWith<$Res>
    implements $QuestionStateCopyWith<$Res> {
  factory _$$_QuestionStateCopyWith(
          _$_QuestionState value, $Res Function(_$_QuestionState) then) =
      __$$_QuestionStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {UniqueId stateId,
      Question question,
      Answer answer,
      bool isSpecialAnswer,
      bool withinCell,
      bool canEdit,
      bool qABoxIsShown,
      bool answerBoxIsShown});

  @override
  $UniqueIdCopyWith<$Res> get stateId;
  @override
  $QuestionCopyWith<$Res> get question;
  @override
  $AnswerCopyWith<$Res> get answer;
}

/// @nodoc
class __$$_QuestionStateCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res>
    implements _$$_QuestionStateCopyWith<$Res> {
  __$$_QuestionStateCopyWithImpl(
      _$_QuestionState _value, $Res Function(_$_QuestionState) _then)
      : super(_value, (v) => _then(v as _$_QuestionState));

  @override
  _$_QuestionState get _value => super._value as _$_QuestionState;

  @override
  $Res call({
    Object? stateId = freezed,
    Object? question = freezed,
    Object? answer = freezed,
    Object? isSpecialAnswer = freezed,
    Object? withinCell = freezed,
    Object? canEdit = freezed,
    Object? qABoxIsShown = freezed,
    Object? answerBoxIsShown = freezed,
  }) {
    return _then(_$_QuestionState(
      stateId: stateId == freezed
          ? _value.stateId
          : stateId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      question: question == freezed
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as Question,
      answer: answer == freezed
          ? _value.answer
          : answer // ignore: cast_nullable_to_non_nullable
              as Answer,
      isSpecialAnswer: isSpecialAnswer == freezed
          ? _value.isSpecialAnswer
          : isSpecialAnswer // ignore: cast_nullable_to_non_nullable
              as bool,
      withinCell: withinCell == freezed
          ? _value.withinCell
          : withinCell // ignore: cast_nullable_to_non_nullable
              as bool,
      canEdit: canEdit == freezed
          ? _value.canEdit
          : canEdit // ignore: cast_nullable_to_non_nullable
              as bool,
      qABoxIsShown: qABoxIsShown == freezed
          ? _value.qABoxIsShown
          : qABoxIsShown // ignore: cast_nullable_to_non_nullable
              as bool,
      answerBoxIsShown: answerBoxIsShown == freezed
          ? _value.answerBoxIsShown
          : answerBoxIsShown // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_QuestionState extends _QuestionState {
  const _$_QuestionState(
      {required this.stateId,
      required this.question,
      required this.answer,
      required this.isSpecialAnswer,
      required this.withinCell,
      required this.canEdit,
      required this.qABoxIsShown,
      required this.answerBoxIsShown})
      : super._();

  @override
  final UniqueId stateId;
  @override
  final Question question;
  @override
  final Answer answer;
  @override
  final bool isSpecialAnswer;
  @override
  final bool withinCell;
  @override
  final bool canEdit;
  @override
  final bool qABoxIsShown;
  @override
  final bool answerBoxIsShown;

  @override
  String toString() {
    return 'QuestionState(stateId: $stateId, question: $question, answer: $answer, isSpecialAnswer: $isSpecialAnswer, withinCell: $withinCell, canEdit: $canEdit, qABoxIsShown: $qABoxIsShown, answerBoxIsShown: $answerBoxIsShown)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QuestionState &&
            const DeepCollectionEquality().equals(other.stateId, stateId) &&
            const DeepCollectionEquality().equals(other.question, question) &&
            const DeepCollectionEquality().equals(other.answer, answer) &&
            const DeepCollectionEquality()
                .equals(other.isSpecialAnswer, isSpecialAnswer) &&
            const DeepCollectionEquality()
                .equals(other.withinCell, withinCell) &&
            const DeepCollectionEquality().equals(other.canEdit, canEdit) &&
            const DeepCollectionEquality()
                .equals(other.qABoxIsShown, qABoxIsShown) &&
            const DeepCollectionEquality()
                .equals(other.answerBoxIsShown, answerBoxIsShown));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(stateId),
      const DeepCollectionEquality().hash(question),
      const DeepCollectionEquality().hash(answer),
      const DeepCollectionEquality().hash(isSpecialAnswer),
      const DeepCollectionEquality().hash(withinCell),
      const DeepCollectionEquality().hash(canEdit),
      const DeepCollectionEquality().hash(qABoxIsShown),
      const DeepCollectionEquality().hash(answerBoxIsShown));

  @JsonKey(ignore: true)
  @override
  _$$_QuestionStateCopyWith<_$_QuestionState> get copyWith =>
      __$$_QuestionStateCopyWithImpl<_$_QuestionState>(this, _$identity);
}

abstract class _QuestionState extends QuestionState {
  const factory _QuestionState(
      {required final UniqueId stateId,
      required final Question question,
      required final Answer answer,
      required final bool isSpecialAnswer,
      required final bool withinCell,
      required final bool canEdit,
      required final bool qABoxIsShown,
      required final bool answerBoxIsShown}) = _$_QuestionState;
  const _QuestionState._() : super._();

  @override
  UniqueId get stateId => throw _privateConstructorUsedError;
  @override
  Question get question => throw _privateConstructorUsedError;
  @override
  Answer get answer => throw _privateConstructorUsedError;
  @override
  bool get isSpecialAnswer => throw _privateConstructorUsedError;
  @override
  bool get withinCell => throw _privateConstructorUsedError;
  @override
  bool get canEdit => throw _privateConstructorUsedError;
  @override
  bool get qABoxIsShown => throw _privateConstructorUsedError;
  @override
  bool get answerBoxIsShown => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_QuestionStateCopyWith<_$_QuestionState> get copyWith =>
      throw _privateConstructorUsedError;
}
