// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'response_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ResponseEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseEventCopyWith<$Res> {
  factory $ResponseEventCopyWith(
          ResponseEvent value, $Res Function(ResponseEvent) then) =
      _$ResponseEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ResponseEventCopyWithImpl<$Res>
    implements $ResponseEventCopyWith<$Res> {
  _$ResponseEventCopyWithImpl(this._value, this._then);

  final ResponseEvent _value;
  // ignore: unused_field
  final $Res Function(ResponseEvent) _then;
}

/// @nodoc
abstract class _$$_WatchResponseMapStartedCopyWith<$Res> {
  factory _$$_WatchResponseMapStartedCopyWith(_$_WatchResponseMapStarted value,
          $Res Function(_$_WatchResponseMapStarted) then) =
      __$$_WatchResponseMapStartedCopyWithImpl<$Res>;
  $Res call({String teamId, Interviewer interviewer});

  $InterviewerCopyWith<$Res> get interviewer;
}

/// @nodoc
class __$$_WatchResponseMapStartedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_WatchResponseMapStartedCopyWith<$Res> {
  __$$_WatchResponseMapStartedCopyWithImpl(_$_WatchResponseMapStarted _value,
      $Res Function(_$_WatchResponseMapStarted) _then)
      : super(_value, (v) => _then(v as _$_WatchResponseMapStarted));

  @override
  _$_WatchResponseMapStarted get _value =>
      super._value as _$_WatchResponseMapStarted;

  @override
  $Res call({
    Object? teamId = freezed,
    Object? interviewer = freezed,
  }) {
    return _then(_$_WatchResponseMapStarted(
      teamId: teamId == freezed
          ? _value.teamId
          : teamId // ignore: cast_nullable_to_non_nullable
              as String,
      interviewer: interviewer == freezed
          ? _value.interviewer
          : interviewer // ignore: cast_nullable_to_non_nullable
              as Interviewer,
    ));
  }

  @override
  $InterviewerCopyWith<$Res> get interviewer {
    return $InterviewerCopyWith<$Res>(_value.interviewer, (value) {
      return _then(_value.copyWith(interviewer: value));
    });
  }
}

/// @nodoc

class _$_WatchResponseMapStarted
    with DiagnosticableTreeMixin
    implements _WatchResponseMapStarted {
  const _$_WatchResponseMapStarted(
      {required this.teamId, required this.interviewer});

  @override
  final String teamId;
  @override
  final Interviewer interviewer;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.watchResponseMapAndReferenceListStarted(teamId: $teamId, interviewer: $interviewer)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ResponseEvent.watchResponseMapAndReferenceListStarted'))
      ..add(DiagnosticsProperty('teamId', teamId))
      ..add(DiagnosticsProperty('interviewer', interviewer));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WatchResponseMapStarted &&
            const DeepCollectionEquality().equals(other.teamId, teamId) &&
            const DeepCollectionEquality()
                .equals(other.interviewer, interviewer));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(teamId),
      const DeepCollectionEquality().hash(interviewer));

  @JsonKey(ignore: true)
  @override
  _$$_WatchResponseMapStartedCopyWith<_$_WatchResponseMapStarted>
      get copyWith =>
          __$$_WatchResponseMapStartedCopyWithImpl<_$_WatchResponseMapStarted>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return watchResponseMapAndReferenceListStarted(teamId, interviewer);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return watchResponseMapAndReferenceListStarted?.call(teamId, interviewer);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (watchResponseMapAndReferenceListStarted != null) {
      return watchResponseMapAndReferenceListStarted(teamId, interviewer);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return watchResponseMapAndReferenceListStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return watchResponseMapAndReferenceListStarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (watchResponseMapAndReferenceListStarted != null) {
      return watchResponseMapAndReferenceListStarted(this);
    }
    return orElse();
  }
}

abstract class _WatchResponseMapStarted implements ResponseEvent {
  const factory _WatchResponseMapStarted(
      {required final String teamId,
      required final Interviewer interviewer}) = _$_WatchResponseMapStarted;

  String get teamId => throw _privateConstructorUsedError;
  Interviewer get interviewer => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_WatchResponseMapStartedCopyWith<_$_WatchResponseMapStarted>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_RawResponseMapReceivedCopyWith<$Res> {
  factory _$$_RawResponseMapReceivedCopyWith(_$_RawResponseMapReceived value,
          $Res Function(_$_RawResponseMapReceived) then) =
      __$$_RawResponseMapReceivedCopyWithImpl<$Res>;
  $Res call({Either<SurveyFailure, List<Object>> failureOrResponseMap});
}

/// @nodoc
class __$$_RawResponseMapReceivedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_RawResponseMapReceivedCopyWith<$Res> {
  __$$_RawResponseMapReceivedCopyWithImpl(_$_RawResponseMapReceived _value,
      $Res Function(_$_RawResponseMapReceived) _then)
      : super(_value, (v) => _then(v as _$_RawResponseMapReceived));

  @override
  _$_RawResponseMapReceived get _value =>
      super._value as _$_RawResponseMapReceived;

  @override
  $Res call({
    Object? failureOrResponseMap = freezed,
  }) {
    return _then(_$_RawResponseMapReceived(
      failureOrResponseMap == freezed
          ? _value.failureOrResponseMap
          : failureOrResponseMap // ignore: cast_nullable_to_non_nullable
              as Either<SurveyFailure, List<Object>>,
    ));
  }
}

/// @nodoc

class _$_RawResponseMapReceived
    with DiagnosticableTreeMixin
    implements _RawResponseMapReceived {
  const _$_RawResponseMapReceived(this.failureOrResponseMap);

  @override
  final Either<SurveyFailure, List<Object>> failureOrResponseMap;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.rawResponseMapReceived(failureOrResponseMap: $failureOrResponseMap)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.rawResponseMapReceived'))
      ..add(DiagnosticsProperty('failureOrResponseMap', failureOrResponseMap));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RawResponseMapReceived &&
            const DeepCollectionEquality()
                .equals(other.failureOrResponseMap, failureOrResponseMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureOrResponseMap));

  @JsonKey(ignore: true)
  @override
  _$$_RawResponseMapReceivedCopyWith<_$_RawResponseMapReceived> get copyWith =>
      __$$_RawResponseMapReceivedCopyWithImpl<_$_RawResponseMapReceived>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return rawResponseMapReceived(failureOrResponseMap);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return rawResponseMapReceived?.call(failureOrResponseMap);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (rawResponseMapReceived != null) {
      return rawResponseMapReceived(failureOrResponseMap);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return rawResponseMapReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return rawResponseMapReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (rawResponseMapReceived != null) {
      return rawResponseMapReceived(this);
    }
    return orElse();
  }
}

abstract class _RawResponseMapReceived implements ResponseEvent {
  const factory _RawResponseMapReceived(
          final Either<SurveyFailure, List<Object>> failureOrResponseMap) =
      _$_RawResponseMapReceived;

  Either<SurveyFailure, List<Object>> get failureOrResponseMap =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_RawResponseMapReceivedCopyWith<_$_RawResponseMapReceived> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_RawReferenceListReceivedCopyWith<$Res> {
  factory _$$_RawReferenceListReceivedCopyWith(
          _$_RawReferenceListReceived value,
          $Res Function(_$_RawReferenceListReceived) then) =
      __$$_RawReferenceListReceivedCopyWithImpl<$Res>;
  $Res call({Either<SurveyFailure, List<Object>> failureOrReferenceList});
}

/// @nodoc
class __$$_RawReferenceListReceivedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_RawReferenceListReceivedCopyWith<$Res> {
  __$$_RawReferenceListReceivedCopyWithImpl(_$_RawReferenceListReceived _value,
      $Res Function(_$_RawReferenceListReceived) _then)
      : super(_value, (v) => _then(v as _$_RawReferenceListReceived));

  @override
  _$_RawReferenceListReceived get _value =>
      super._value as _$_RawReferenceListReceived;

  @override
  $Res call({
    Object? failureOrReferenceList = freezed,
  }) {
    return _then(_$_RawReferenceListReceived(
      failureOrReferenceList == freezed
          ? _value.failureOrReferenceList
          : failureOrReferenceList // ignore: cast_nullable_to_non_nullable
              as Either<SurveyFailure, List<Object>>,
    ));
  }
}

/// @nodoc

class _$_RawReferenceListReceived
    with DiagnosticableTreeMixin
    implements _RawReferenceListReceived {
  const _$_RawReferenceListReceived(this.failureOrReferenceList);

  @override
  final Either<SurveyFailure, List<Object>> failureOrReferenceList;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.rawReferenceListReceived(failureOrReferenceList: $failureOrReferenceList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'ResponseEvent.rawReferenceListReceived'))
      ..add(DiagnosticsProperty(
          'failureOrReferenceList', failureOrReferenceList));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RawReferenceListReceived &&
            const DeepCollectionEquality()
                .equals(other.failureOrReferenceList, failureOrReferenceList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureOrReferenceList));

  @JsonKey(ignore: true)
  @override
  _$$_RawReferenceListReceivedCopyWith<_$_RawReferenceListReceived>
      get copyWith => __$$_RawReferenceListReceivedCopyWithImpl<
          _$_RawReferenceListReceived>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return rawReferenceListReceived(failureOrReferenceList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return rawReferenceListReceived?.call(failureOrReferenceList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (rawReferenceListReceived != null) {
      return rawReferenceListReceived(failureOrReferenceList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return rawReferenceListReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return rawReferenceListReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (rawReferenceListReceived != null) {
      return rawReferenceListReceived(this);
    }
    return orElse();
  }
}

abstract class _RawReferenceListReceived implements ResponseEvent {
  const factory _RawReferenceListReceived(
          final Either<SurveyFailure, List<Object>> failureOrReferenceList) =
      _$_RawReferenceListReceived;

  Either<SurveyFailure, List<Object>> get failureOrReferenceList =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_RawReferenceListReceivedCopyWith<_$_RawReferenceListReceived>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UploadTimerUpdatedCopyWith<$Res> {
  factory _$$_UploadTimerUpdatedCopyWith(_$_UploadTimerUpdated value,
          $Res Function(_$_UploadTimerUpdated) then) =
      __$$_UploadTimerUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UploadTimerUpdatedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_UploadTimerUpdatedCopyWith<$Res> {
  __$$_UploadTimerUpdatedCopyWithImpl(
      _$_UploadTimerUpdated _value, $Res Function(_$_UploadTimerUpdated) _then)
      : super(_value, (v) => _then(v as _$_UploadTimerUpdated));

  @override
  _$_UploadTimerUpdated get _value => super._value as _$_UploadTimerUpdated;
}

/// @nodoc

class _$_UploadTimerUpdated
    with DiagnosticableTreeMixin
    implements _UploadTimerUpdated {
  const _$_UploadTimerUpdated();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.uploadTimerUpdated()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ResponseEvent.uploadTimerUpdated'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UploadTimerUpdated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return uploadTimerUpdated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return uploadTimerUpdated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (uploadTimerUpdated != null) {
      return uploadTimerUpdated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return uploadTimerUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return uploadTimerUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (uploadTimerUpdated != null) {
      return uploadTimerUpdated(this);
    }
    return orElse();
  }
}

abstract class _UploadTimerUpdated implements ResponseEvent {
  const factory _UploadTimerUpdated() = _$_UploadTimerUpdated;
}

/// @nodoc
abstract class _$$_ResponseMapUploadingCopyWith<$Res> {
  factory _$$_ResponseMapUploadingCopyWith(_$_ResponseMapUploading value,
          $Res Function(_$_ResponseMapUploading) then) =
      __$$_ResponseMapUploadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ResponseMapUploadingCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_ResponseMapUploadingCopyWith<$Res> {
  __$$_ResponseMapUploadingCopyWithImpl(_$_ResponseMapUploading _value,
      $Res Function(_$_ResponseMapUploading) _then)
      : super(_value, (v) => _then(v as _$_ResponseMapUploading));

  @override
  _$_ResponseMapUploading get _value => super._value as _$_ResponseMapUploading;
}

/// @nodoc

class _$_ResponseMapUploading
    with DiagnosticableTreeMixin
    implements _ResponseMapUploading {
  const _$_ResponseMapUploading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.responseMapUploading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ResponseEvent.responseMapUploading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ResponseMapUploading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return responseMapUploading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return responseMapUploading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (responseMapUploading != null) {
      return responseMapUploading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return responseMapUploading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return responseMapUploading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (responseMapUploading != null) {
      return responseMapUploading(this);
    }
    return orElse();
  }
}

abstract class _ResponseMapUploading implements ResponseEvent {
  const factory _ResponseMapUploading() = _$_ResponseMapUploading;
}

/// @nodoc
abstract class _$$_ResponseUploadedCopyWith<$Res> {
  factory _$$_ResponseUploadedCopyWith(
          _$_ResponseUploaded value, $Res Function(_$_ResponseUploaded) then) =
      __$$_ResponseUploadedCopyWithImpl<$Res>;
  $Res call({Either<SurveyFailure, String> failureOrResult});
}

/// @nodoc
class __$$_ResponseUploadedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_ResponseUploadedCopyWith<$Res> {
  __$$_ResponseUploadedCopyWithImpl(
      _$_ResponseUploaded _value, $Res Function(_$_ResponseUploaded) _then)
      : super(_value, (v) => _then(v as _$_ResponseUploaded));

  @override
  _$_ResponseUploaded get _value => super._value as _$_ResponseUploaded;

  @override
  $Res call({
    Object? failureOrResult = freezed,
  }) {
    return _then(_$_ResponseUploaded(
      failureOrResult == freezed
          ? _value.failureOrResult
          : failureOrResult // ignore: cast_nullable_to_non_nullable
              as Either<SurveyFailure, String>,
    ));
  }
}

/// @nodoc

class _$_ResponseUploaded
    with DiagnosticableTreeMixin
    implements _ResponseUploaded {
  const _$_ResponseUploaded(this.failureOrResult);

  @override
  final Either<SurveyFailure, String> failureOrResult;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.responseUploaded(failureOrResult: $failureOrResult)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.responseUploaded'))
      ..add(DiagnosticsProperty('failureOrResult', failureOrResult));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseUploaded &&
            const DeepCollectionEquality()
                .equals(other.failureOrResult, failureOrResult));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureOrResult));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseUploadedCopyWith<_$_ResponseUploaded> get copyWith =>
      __$$_ResponseUploadedCopyWithImpl<_$_ResponseUploaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return responseUploaded(failureOrResult);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return responseUploaded?.call(failureOrResult);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (responseUploaded != null) {
      return responseUploaded(failureOrResult);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return responseUploaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return responseUploaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (responseUploaded != null) {
      return responseUploaded(this);
    }
    return orElse();
  }
}

abstract class _ResponseUploaded implements ResponseEvent {
  const factory _ResponseUploaded(
          final Either<SurveyFailure, String> failureOrResult) =
      _$_ResponseUploaded;

  Either<SurveyFailure, String> get failureOrResult =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ResponseUploadedCopyWith<_$_ResponseUploaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SurveySelectedCopyWith<$Res> {
  factory _$$_SurveySelectedCopyWith(
          _$_SurveySelected value, $Res Function(_$_SurveySelected) then) =
      __$$_SurveySelectedCopyWithImpl<$Res>;
  $Res call({Survey survey});

  $SurveyCopyWith<$Res> get survey;
}

/// @nodoc
class __$$_SurveySelectedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_SurveySelectedCopyWith<$Res> {
  __$$_SurveySelectedCopyWithImpl(
      _$_SurveySelected _value, $Res Function(_$_SurveySelected) _then)
      : super(_value, (v) => _then(v as _$_SurveySelected));

  @override
  _$_SurveySelected get _value => super._value as _$_SurveySelected;

  @override
  $Res call({
    Object? survey = freezed,
  }) {
    return _then(_$_SurveySelected(
      survey: survey == freezed
          ? _value.survey
          : survey // ignore: cast_nullable_to_non_nullable
              as Survey,
    ));
  }

  @override
  $SurveyCopyWith<$Res> get survey {
    return $SurveyCopyWith<$Res>(_value.survey, (value) {
      return _then(_value.copyWith(survey: value));
    });
  }
}

/// @nodoc

class _$_SurveySelected
    with DiagnosticableTreeMixin
    implements _SurveySelected {
  const _$_SurveySelected({required this.survey});

  @override
  final Survey survey;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.surveySelected(survey: $survey)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.surveySelected'))
      ..add(DiagnosticsProperty('survey', survey));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SurveySelected &&
            const DeepCollectionEquality().equals(other.survey, survey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(survey));

  @JsonKey(ignore: true)
  @override
  _$$_SurveySelectedCopyWith<_$_SurveySelected> get copyWith =>
      __$$_SurveySelectedCopyWithImpl<_$_SurveySelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return surveySelected(survey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return surveySelected?.call(survey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (surveySelected != null) {
      return surveySelected(survey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return surveySelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return surveySelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (surveySelected != null) {
      return surveySelected(this);
    }
    return orElse();
  }
}

abstract class _SurveySelected implements ResponseEvent {
  const factory _SurveySelected({required final Survey survey}) =
      _$_SurveySelected;

  Survey get survey => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_SurveySelectedCopyWith<_$_SurveySelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ResponseStartedCopyWith<$Res> {
  factory _$$_ResponseStartedCopyWith(
          _$_ResponseStarted value, $Res Function(_$_ResponseStarted) then) =
      __$$_ResponseStartedCopyWithImpl<$Res>;
  $Res call(
      {Respondent respondent,
      ModuleType moduleType,
      bool withResponseId,
      bool breakInterview,
      bool isNewResponse,
      UniqueId? responseId});

  $RespondentCopyWith<$Res> get respondent;
  $ModuleTypeCopyWith<$Res> get moduleType;
  $UniqueIdCopyWith<$Res>? get responseId;
}

/// @nodoc
class __$$_ResponseStartedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_ResponseStartedCopyWith<$Res> {
  __$$_ResponseStartedCopyWithImpl(
      _$_ResponseStarted _value, $Res Function(_$_ResponseStarted) _then)
      : super(_value, (v) => _then(v as _$_ResponseStarted));

  @override
  _$_ResponseStarted get _value => super._value as _$_ResponseStarted;

  @override
  $Res call({
    Object? respondent = freezed,
    Object? moduleType = freezed,
    Object? withResponseId = freezed,
    Object? breakInterview = freezed,
    Object? isNewResponse = freezed,
    Object? responseId = freezed,
  }) {
    return _then(_$_ResponseStarted(
      respondent: respondent == freezed
          ? _value.respondent
          : respondent // ignore: cast_nullable_to_non_nullable
              as Respondent,
      moduleType: moduleType == freezed
          ? _value.moduleType
          : moduleType // ignore: cast_nullable_to_non_nullable
              as ModuleType,
      withResponseId: withResponseId == freezed
          ? _value.withResponseId
          : withResponseId // ignore: cast_nullable_to_non_nullable
              as bool,
      breakInterview: breakInterview == freezed
          ? _value.breakInterview
          : breakInterview // ignore: cast_nullable_to_non_nullable
              as bool,
      isNewResponse: isNewResponse == freezed
          ? _value.isNewResponse
          : isNewResponse // ignore: cast_nullable_to_non_nullable
              as bool,
      responseId: responseId == freezed
          ? _value.responseId
          : responseId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
    ));
  }

  @override
  $RespondentCopyWith<$Res> get respondent {
    return $RespondentCopyWith<$Res>(_value.respondent, (value) {
      return _then(_value.copyWith(respondent: value));
    });
  }

  @override
  $ModuleTypeCopyWith<$Res> get moduleType {
    return $ModuleTypeCopyWith<$Res>(_value.moduleType, (value) {
      return _then(_value.copyWith(moduleType: value));
    });
  }

  @override
  $UniqueIdCopyWith<$Res>? get responseId {
    if (_value.responseId == null) {
      return null;
    }

    return $UniqueIdCopyWith<$Res>(_value.responseId!, (value) {
      return _then(_value.copyWith(responseId: value));
    });
  }
}

/// @nodoc

class _$_ResponseStarted
    with DiagnosticableTreeMixin
    implements _ResponseStarted {
  const _$_ResponseStarted(
      {required this.respondent,
      required this.moduleType,
      this.withResponseId = false,
      this.breakInterview = false,
      this.isNewResponse = false,
      this.responseId});

  @override
  final Respondent respondent;
  @override
  final ModuleType moduleType;
  @override
  @JsonKey()
  final bool withResponseId;
  @override
  @JsonKey()
  final bool breakInterview;
  @override
  @JsonKey()
  final bool isNewResponse;
  @override
  final UniqueId? responseId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.responseStarted(respondent: $respondent, moduleType: $moduleType, withResponseId: $withResponseId, breakInterview: $breakInterview, isNewResponse: $isNewResponse, responseId: $responseId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.responseStarted'))
      ..add(DiagnosticsProperty('respondent', respondent))
      ..add(DiagnosticsProperty('moduleType', moduleType))
      ..add(DiagnosticsProperty('withResponseId', withResponseId))
      ..add(DiagnosticsProperty('breakInterview', breakInterview))
      ..add(DiagnosticsProperty('isNewResponse', isNewResponse))
      ..add(DiagnosticsProperty('responseId', responseId));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseStarted &&
            const DeepCollectionEquality()
                .equals(other.respondent, respondent) &&
            const DeepCollectionEquality()
                .equals(other.moduleType, moduleType) &&
            const DeepCollectionEquality()
                .equals(other.withResponseId, withResponseId) &&
            const DeepCollectionEquality()
                .equals(other.breakInterview, breakInterview) &&
            const DeepCollectionEquality()
                .equals(other.isNewResponse, isNewResponse) &&
            const DeepCollectionEquality()
                .equals(other.responseId, responseId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(respondent),
      const DeepCollectionEquality().hash(moduleType),
      const DeepCollectionEquality().hash(withResponseId),
      const DeepCollectionEquality().hash(breakInterview),
      const DeepCollectionEquality().hash(isNewResponse),
      const DeepCollectionEquality().hash(responseId));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseStartedCopyWith<_$_ResponseStarted> get copyWith =>
      __$$_ResponseStartedCopyWithImpl<_$_ResponseStarted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return responseStarted(respondent, moduleType, withResponseId,
        breakInterview, isNewResponse, responseId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return responseStarted?.call(respondent, moduleType, withResponseId,
        breakInterview, isNewResponse, responseId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (responseStarted != null) {
      return responseStarted(respondent, moduleType, withResponseId,
          breakInterview, isNewResponse, responseId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return responseStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return responseStarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (responseStarted != null) {
      return responseStarted(this);
    }
    return orElse();
  }
}

abstract class _ResponseStarted implements ResponseEvent {
  const factory _ResponseStarted(
      {required final Respondent respondent,
      required final ModuleType moduleType,
      final bool withResponseId,
      final bool breakInterview,
      final bool isNewResponse,
      final UniqueId? responseId}) = _$_ResponseStarted;

  Respondent get respondent => throw _privateConstructorUsedError;
  ModuleType get moduleType => throw _privateConstructorUsedError;
  bool get withResponseId => throw _privateConstructorUsedError;
  bool get breakInterview => throw _privateConstructorUsedError;
  bool get isNewResponse => throw _privateConstructorUsedError;
  UniqueId? get responseId => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ResponseStartedCopyWith<_$_ResponseStarted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ResponseUpdatedCopyWith<$Res> {
  factory _$$_ResponseUpdatedCopyWith(
          _$_ResponseUpdated value, $Res Function(_$_ResponseUpdated) then) =
      __$$_ResponseUpdatedCopyWithImpl<$Res>;
  $Res call(
      {Map<String, Answer> answerMap,
      Map<String, AnswerStatus> answerStatusMap,
      SimpleSurveyPageState surveyPageState});

  $SimpleSurveyPageStateCopyWith<$Res> get surveyPageState;
}

/// @nodoc
class __$$_ResponseUpdatedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_ResponseUpdatedCopyWith<$Res> {
  __$$_ResponseUpdatedCopyWithImpl(
      _$_ResponseUpdated _value, $Res Function(_$_ResponseUpdated) _then)
      : super(_value, (v) => _then(v as _$_ResponseUpdated));

  @override
  _$_ResponseUpdated get _value => super._value as _$_ResponseUpdated;

  @override
  $Res call({
    Object? answerMap = freezed,
    Object? answerStatusMap = freezed,
    Object? surveyPageState = freezed,
  }) {
    return _then(_$_ResponseUpdated(
      answerMap: answerMap == freezed
          ? _value._answerMap
          : answerMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Answer>,
      answerStatusMap: answerStatusMap == freezed
          ? _value._answerStatusMap
          : answerStatusMap // ignore: cast_nullable_to_non_nullable
              as Map<String, AnswerStatus>,
      surveyPageState: surveyPageState == freezed
          ? _value.surveyPageState
          : surveyPageState // ignore: cast_nullable_to_non_nullable
              as SimpleSurveyPageState,
    ));
  }

  @override
  $SimpleSurveyPageStateCopyWith<$Res> get surveyPageState {
    return $SimpleSurveyPageStateCopyWith<$Res>(_value.surveyPageState,
        (value) {
      return _then(_value.copyWith(surveyPageState: value));
    });
  }
}

/// @nodoc

class _$_ResponseUpdated
    with DiagnosticableTreeMixin
    implements _ResponseUpdated {
  const _$_ResponseUpdated(
      {required final Map<String, Answer> answerMap,
      required final Map<String, AnswerStatus> answerStatusMap,
      required this.surveyPageState})
      : _answerMap = answerMap,
        _answerStatusMap = answerStatusMap;

  final Map<String, Answer> _answerMap;
  @override
  Map<String, Answer> get answerMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_answerMap);
  }

  final Map<String, AnswerStatus> _answerStatusMap;
  @override
  Map<String, AnswerStatus> get answerStatusMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_answerStatusMap);
  }

  @override
  final SimpleSurveyPageState surveyPageState;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.responseUpdated(answerMap: $answerMap, answerStatusMap: $answerStatusMap, surveyPageState: $surveyPageState)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.responseUpdated'))
      ..add(DiagnosticsProperty('answerMap', answerMap))
      ..add(DiagnosticsProperty('answerStatusMap', answerStatusMap))
      ..add(DiagnosticsProperty('surveyPageState', surveyPageState));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseUpdated &&
            const DeepCollectionEquality()
                .equals(other._answerMap, _answerMap) &&
            const DeepCollectionEquality()
                .equals(other._answerStatusMap, _answerStatusMap) &&
            const DeepCollectionEquality()
                .equals(other.surveyPageState, surveyPageState));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_answerMap),
      const DeepCollectionEquality().hash(_answerStatusMap),
      const DeepCollectionEquality().hash(surveyPageState));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseUpdatedCopyWith<_$_ResponseUpdated> get copyWith =>
      __$$_ResponseUpdatedCopyWithImpl<_$_ResponseUpdated>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return responseUpdated(answerMap, answerStatusMap, surveyPageState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return responseUpdated?.call(answerMap, answerStatusMap, surveyPageState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (responseUpdated != null) {
      return responseUpdated(answerMap, answerStatusMap, surveyPageState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return responseUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return responseUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (responseUpdated != null) {
      return responseUpdated(this);
    }
    return orElse();
  }
}

abstract class _ResponseUpdated implements ResponseEvent {
  const factory _ResponseUpdated(
          {required final Map<String, Answer> answerMap,
          required final Map<String, AnswerStatus> answerStatusMap,
          required final SimpleSurveyPageState surveyPageState}) =
      _$_ResponseUpdated;

  Map<String, Answer> get answerMap => throw _privateConstructorUsedError;
  Map<String, AnswerStatus> get answerStatusMap =>
      throw _privateConstructorUsedError;
  SimpleSurveyPageState get surveyPageState =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ResponseUpdatedCopyWith<_$_ResponseUpdated> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_EditFinishedCopyWith<$Res> {
  factory _$$_EditFinishedCopyWith(
          _$_EditFinished value, $Res Function(_$_EditFinished) then) =
      __$$_EditFinishedCopyWithImpl<$Res>;
  $Res call({bool responseFinished});
}

/// @nodoc
class __$$_EditFinishedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_EditFinishedCopyWith<$Res> {
  __$$_EditFinishedCopyWithImpl(
      _$_EditFinished _value, $Res Function(_$_EditFinished) _then)
      : super(_value, (v) => _then(v as _$_EditFinished));

  @override
  _$_EditFinished get _value => super._value as _$_EditFinished;

  @override
  $Res call({
    Object? responseFinished = freezed,
  }) {
    return _then(_$_EditFinished(
      responseFinished: responseFinished == freezed
          ? _value.responseFinished
          : responseFinished // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_EditFinished with DiagnosticableTreeMixin implements _EditFinished {
  const _$_EditFinished({required this.responseFinished});

// * 是否完成這份問卷
  @override
  final bool responseFinished;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.editFinished(responseFinished: $responseFinished)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.editFinished'))
      ..add(DiagnosticsProperty('responseFinished', responseFinished));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EditFinished &&
            const DeepCollectionEquality()
                .equals(other.responseFinished, responseFinished));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(responseFinished));

  @JsonKey(ignore: true)
  @override
  _$$_EditFinishedCopyWith<_$_EditFinished> get copyWith =>
      __$$_EditFinishedCopyWithImpl<_$_EditFinished>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return editFinished(responseFinished);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return editFinished?.call(responseFinished);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (editFinished != null) {
      return editFinished(responseFinished);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return editFinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return editFinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (editFinished != null) {
      return editFinished(this);
    }
    return orElse();
  }
}

abstract class _EditFinished implements ResponseEvent {
  const factory _EditFinished({required final bool responseFinished}) =
      _$_EditFinished;

// * 是否完成這份問卷
  bool get responseFinished => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_EditFinishedCopyWith<_$_EditFinished> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ResponseResumedCopyWith<$Res> {
  factory _$$_ResponseResumedCopyWith(
          _$_ResponseResumed value, $Res Function(_$_ResponseResumed) then) =
      __$$_ResponseResumedCopyWithImpl<$Res>;
  $Res call({UniqueId responseId});

  $UniqueIdCopyWith<$Res> get responseId;
}

/// @nodoc
class __$$_ResponseResumedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_ResponseResumedCopyWith<$Res> {
  __$$_ResponseResumedCopyWithImpl(
      _$_ResponseResumed _value, $Res Function(_$_ResponseResumed) _then)
      : super(_value, (v) => _then(v as _$_ResponseResumed));

  @override
  _$_ResponseResumed get _value => super._value as _$_ResponseResumed;

  @override
  $Res call({
    Object? responseId = freezed,
  }) {
    return _then(_$_ResponseResumed(
      responseId == freezed
          ? _value.responseId
          : responseId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }

  @override
  $UniqueIdCopyWith<$Res> get responseId {
    return $UniqueIdCopyWith<$Res>(_value.responseId, (value) {
      return _then(_value.copyWith(responseId: value));
    });
  }
}

/// @nodoc

class _$_ResponseResumed
    with DiagnosticableTreeMixin
    implements _ResponseResumed {
  const _$_ResponseResumed(this.responseId);

  @override
  final UniqueId responseId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.responseResumed(responseId: $responseId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.responseResumed'))
      ..add(DiagnosticsProperty('responseId', responseId));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseResumed &&
            const DeepCollectionEquality()
                .equals(other.responseId, responseId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(responseId));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseResumedCopyWith<_$_ResponseResumed> get copyWith =>
      __$$_ResponseResumedCopyWithImpl<_$_ResponseResumed>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return responseResumed(responseId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return responseResumed?.call(responseId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (responseResumed != null) {
      return responseResumed(responseId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return responseResumed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return responseResumed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (responseResumed != null) {
      return responseResumed(this);
    }
    return orElse();
  }
}

abstract class _ResponseResumed implements ResponseEvent {
  const factory _ResponseResumed(final UniqueId responseId) =
      _$_ResponseResumed;

  UniqueId get responseId => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ResponseResumedCopyWith<_$_ResponseResumed> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_NetworkUpdatedCopyWith<$Res> {
  factory _$$_NetworkUpdatedCopyWith(
          _$_NetworkUpdated value, $Res Function(_$_NetworkUpdated) then) =
      __$$_NetworkUpdatedCopyWithImpl<$Res>;
  $Res call({NetworkType networkType});

  $NetworkTypeCopyWith<$Res> get networkType;
}

/// @nodoc
class __$$_NetworkUpdatedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_NetworkUpdatedCopyWith<$Res> {
  __$$_NetworkUpdatedCopyWithImpl(
      _$_NetworkUpdated _value, $Res Function(_$_NetworkUpdated) _then)
      : super(_value, (v) => _then(v as _$_NetworkUpdated));

  @override
  _$_NetworkUpdated get _value => super._value as _$_NetworkUpdated;

  @override
  $Res call({
    Object? networkType = freezed,
  }) {
    return _then(_$_NetworkUpdated(
      networkType: networkType == freezed
          ? _value.networkType
          : networkType // ignore: cast_nullable_to_non_nullable
              as NetworkType,
    ));
  }

  @override
  $NetworkTypeCopyWith<$Res> get networkType {
    return $NetworkTypeCopyWith<$Res>(_value.networkType, (value) {
      return _then(_value.copyWith(networkType: value));
    });
  }
}

/// @nodoc

class _$_NetworkUpdated
    with DiagnosticableTreeMixin
    implements _NetworkUpdated {
  const _$_NetworkUpdated({required this.networkType});

  @override
  final NetworkType networkType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.networkUpdated(networkType: $networkType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseEvent.networkUpdated'))
      ..add(DiagnosticsProperty('networkType', networkType));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NetworkUpdated &&
            const DeepCollectionEquality()
                .equals(other.networkType, networkType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(networkType));

  @JsonKey(ignore: true)
  @override
  _$$_NetworkUpdatedCopyWith<_$_NetworkUpdated> get copyWith =>
      __$$_NetworkUpdatedCopyWithImpl<_$_NetworkUpdated>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return networkUpdated(networkType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return networkUpdated?.call(networkType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (networkUpdated != null) {
      return networkUpdated(networkType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return networkUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return networkUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (networkUpdated != null) {
      return networkUpdated(this);
    }
    return orElse();
  }
}

abstract class _NetworkUpdated implements ResponseEvent {
  const factory _NetworkUpdated({required final NetworkType networkType}) =
      _$_NetworkUpdated;

  NetworkType get networkType => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_NetworkUpdatedCopyWith<_$_NetworkUpdated> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_LoggedOutCopyWith<$Res> {
  factory _$$_LoggedOutCopyWith(
          _$_LoggedOut value, $Res Function(_$_LoggedOut) then) =
      __$$_LoggedOutCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LoggedOutCopyWithImpl<$Res> extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_LoggedOutCopyWith<$Res> {
  __$$_LoggedOutCopyWithImpl(
      _$_LoggedOut _value, $Res Function(_$_LoggedOut) _then)
      : super(_value, (v) => _then(v as _$_LoggedOut));

  @override
  _$_LoggedOut get _value => super._value as _$_LoggedOut;
}

/// @nodoc

class _$_LoggedOut with DiagnosticableTreeMixin implements _LoggedOut {
  const _$_LoggedOut();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.loggedOut()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ResponseEvent.loggedOut'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_LoggedOut);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return loggedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return loggedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return loggedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return loggedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut(this);
    }
    return orElse();
  }
}

abstract class _LoggedOut implements ResponseEvent {
  const factory _LoggedOut() = _$_LoggedOut;
}

/// @nodoc
abstract class _$$_InitializedCopyWith<$Res> {
  factory _$$_InitializedCopyWith(
          _$_Initialized value, $Res Function(_$_Initialized) then) =
      __$$_InitializedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitializedCopyWithImpl<$Res>
    extends _$ResponseEventCopyWithImpl<$Res>
    implements _$$_InitializedCopyWith<$Res> {
  __$$_InitializedCopyWithImpl(
      _$_Initialized _value, $Res Function(_$_Initialized) _then)
      : super(_value, (v) => _then(v as _$_Initialized));

  @override
  _$_Initialized get _value => super._value as _$_Initialized;
}

/// @nodoc

class _$_Initialized with DiagnosticableTreeMixin implements _Initialized {
  const _$_Initialized();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseEvent.initialized()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ResponseEvent.initialized'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String teamId, Interviewer interviewer)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrResponseMap)
        rawResponseMapReceived,
    required TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)
        rawReferenceListReceived,
    required TResult Function() uploadTimerUpdated,
    required TResult Function() responseMapUploading,
    required TResult Function(Either<SurveyFailure, String> failureOrResult)
        responseUploaded,
    required TResult Function(Survey survey) surveySelected,
    required TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)
        responseStarted,
    required TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)
        responseUpdated,
    required TResult Function(bool responseFinished) editFinished,
    required TResult Function(UniqueId responseId) responseResumed,
    required TResult Function(NetworkType networkType) networkUpdated,
    required TResult Function() loggedOut,
    required TResult Function() initialized,
  }) {
    return initialized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
  }) {
    return initialized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String teamId, Interviewer interviewer)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(Either<SurveyFailure, List<Object>> failureOrResponseMap)?
        rawResponseMapReceived,
    TResult Function(
            Either<SurveyFailure, List<Object>> failureOrReferenceList)?
        rawReferenceListReceived,
    TResult Function()? uploadTimerUpdated,
    TResult Function()? responseMapUploading,
    TResult Function(Either<SurveyFailure, String> failureOrResult)?
        responseUploaded,
    TResult Function(Survey survey)? surveySelected,
    TResult Function(
            Respondent respondent,
            ModuleType moduleType,
            bool withResponseId,
            bool breakInterview,
            bool isNewResponse,
            UniqueId? responseId)?
        responseStarted,
    TResult Function(
            Map<String, Answer> answerMap,
            Map<String, AnswerStatus> answerStatusMap,
            SimpleSurveyPageState surveyPageState)?
        responseUpdated,
    TResult Function(bool responseFinished)? editFinished,
    TResult Function(UniqueId responseId)? responseResumed,
    TResult Function(NetworkType networkType)? networkUpdated,
    TResult Function()? loggedOut,
    TResult Function()? initialized,
    required TResult orElse(),
  }) {
    if (initialized != null) {
      return initialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WatchResponseMapStarted value)
        watchResponseMapAndReferenceListStarted,
    required TResult Function(_RawResponseMapReceived value)
        rawResponseMapReceived,
    required TResult Function(_RawReferenceListReceived value)
        rawReferenceListReceived,
    required TResult Function(_UploadTimerUpdated value) uploadTimerUpdated,
    required TResult Function(_ResponseMapUploading value) responseMapUploading,
    required TResult Function(_ResponseUploaded value) responseUploaded,
    required TResult Function(_SurveySelected value) surveySelected,
    required TResult Function(_ResponseStarted value) responseStarted,
    required TResult Function(_ResponseUpdated value) responseUpdated,
    required TResult Function(_EditFinished value) editFinished,
    required TResult Function(_ResponseResumed value) responseResumed,
    required TResult Function(_NetworkUpdated value) networkUpdated,
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_Initialized value) initialized,
  }) {
    return initialized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
  }) {
    return initialized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WatchResponseMapStarted value)?
        watchResponseMapAndReferenceListStarted,
    TResult Function(_RawResponseMapReceived value)? rawResponseMapReceived,
    TResult Function(_RawReferenceListReceived value)? rawReferenceListReceived,
    TResult Function(_UploadTimerUpdated value)? uploadTimerUpdated,
    TResult Function(_ResponseMapUploading value)? responseMapUploading,
    TResult Function(_ResponseUploaded value)? responseUploaded,
    TResult Function(_SurveySelected value)? surveySelected,
    TResult Function(_ResponseStarted value)? responseStarted,
    TResult Function(_ResponseUpdated value)? responseUpdated,
    TResult Function(_EditFinished value)? editFinished,
    TResult Function(_ResponseResumed value)? responseResumed,
    TResult Function(_NetworkUpdated value)? networkUpdated,
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_Initialized value)? initialized,
    required TResult orElse(),
  }) {
    if (initialized != null) {
      return initialized(this);
    }
    return orElse();
  }
}

abstract class _Initialized implements ResponseEvent {
  const factory _Initialized() = _$_Initialized;
}

/// @nodoc
mixin _$ResponseState {
  UniqueId get stateId => throw _privateConstructorUsedError; // > 主要資料
  Survey get survey => throw _privateConstructorUsedError;
  Interviewer get interviewer => throw _privateConstructorUsedError;
  Respondent get respondent => throw _privateConstructorUsedError;
  Response get response => throw _privateConstructorUsedError;
  Map<UniqueId, Response> get responseMap => throw _privateConstructorUsedError;
  List<Reference> get referenceList =>
      throw _privateConstructorUsedError; // > 中間資料
  ModuleType get moduleType => throw _privateConstructorUsedError;
  UniqueId get responseId => throw _privateConstructorUsedError;
  Response get mainResponse => throw _privateConstructorUsedError;
  Map<String, Question> get questionMap => throw _privateConstructorUsedError;
  Set<UniqueId> get uploadResponseIdSet => throw _privateConstructorUsedError;
  Map<UniqueId, Response> get downloadedResponseMap =>
      throw _privateConstructorUsedError;
  Map<String, Map<String, dynamic>> get uploadResponseMap =>
      throw _privateConstructorUsedError;
  Map<ModuleType, Response> get respondentResponseMap =>
      throw _privateConstructorUsedError;
  DialogType get dialogType => throw _privateConstructorUsedError;
  NetworkType get networkType => throw _privateConstructorUsedError; // > 狀態更新進度
  LoadState get responseMapState => throw _privateConstructorUsedError;
  SyncState get syncState => throw _privateConstructorUsedError;
  Option<SurveyFailure> get responseFailure =>
      throw _privateConstructorUsedError;
  LoadState get eventState => throw _privateConstructorUsedError;
  LoadState get updateState => throw _privateConstructorUsedError; // > 更新/儲存參數
  StateParameters get updateParameters => throw _privateConstructorUsedError;
  StateParameters get saveParameters => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ResponseStateCopyWith<ResponseState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseStateCopyWith<$Res> {
  factory $ResponseStateCopyWith(
          ResponseState value, $Res Function(ResponseState) then) =
      _$ResponseStateCopyWithImpl<$Res>;
  $Res call(
      {UniqueId stateId,
      Survey survey,
      Interviewer interviewer,
      Respondent respondent,
      Response response,
      Map<UniqueId, Response> responseMap,
      List<Reference> referenceList,
      ModuleType moduleType,
      UniqueId responseId,
      Response mainResponse,
      Map<String, Question> questionMap,
      Set<UniqueId> uploadResponseIdSet,
      Map<UniqueId, Response> downloadedResponseMap,
      Map<String, Map<String, dynamic>> uploadResponseMap,
      Map<ModuleType, Response> respondentResponseMap,
      DialogType dialogType,
      NetworkType networkType,
      LoadState responseMapState,
      SyncState syncState,
      Option<SurveyFailure> responseFailure,
      LoadState eventState,
      LoadState updateState,
      StateParameters updateParameters,
      StateParameters saveParameters});

  $UniqueIdCopyWith<$Res> get stateId;
  $SurveyCopyWith<$Res> get survey;
  $InterviewerCopyWith<$Res> get interviewer;
  $RespondentCopyWith<$Res> get respondent;
  $ResponseCopyWith<$Res> get response;
  $ModuleTypeCopyWith<$Res> get moduleType;
  $UniqueIdCopyWith<$Res> get responseId;
  $ResponseCopyWith<$Res> get mainResponse;
  $DialogTypeCopyWith<$Res> get dialogType;
  $NetworkTypeCopyWith<$Res> get networkType;
  $LoadStateCopyWith<$Res> get responseMapState;
  $SyncStateCopyWith<$Res> get syncState;
  $LoadStateCopyWith<$Res> get eventState;
  $LoadStateCopyWith<$Res> get updateState;
  $StateParametersCopyWith<$Res> get updateParameters;
  $StateParametersCopyWith<$Res> get saveParameters;
}

/// @nodoc
class _$ResponseStateCopyWithImpl<$Res>
    implements $ResponseStateCopyWith<$Res> {
  _$ResponseStateCopyWithImpl(this._value, this._then);

  final ResponseState _value;
  // ignore: unused_field
  final $Res Function(ResponseState) _then;

  @override
  $Res call({
    Object? stateId = freezed,
    Object? survey = freezed,
    Object? interviewer = freezed,
    Object? respondent = freezed,
    Object? response = freezed,
    Object? responseMap = freezed,
    Object? referenceList = freezed,
    Object? moduleType = freezed,
    Object? responseId = freezed,
    Object? mainResponse = freezed,
    Object? questionMap = freezed,
    Object? uploadResponseIdSet = freezed,
    Object? downloadedResponseMap = freezed,
    Object? uploadResponseMap = freezed,
    Object? respondentResponseMap = freezed,
    Object? dialogType = freezed,
    Object? networkType = freezed,
    Object? responseMapState = freezed,
    Object? syncState = freezed,
    Object? responseFailure = freezed,
    Object? eventState = freezed,
    Object? updateState = freezed,
    Object? updateParameters = freezed,
    Object? saveParameters = freezed,
  }) {
    return _then(_value.copyWith(
      stateId: stateId == freezed
          ? _value.stateId
          : stateId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      survey: survey == freezed
          ? _value.survey
          : survey // ignore: cast_nullable_to_non_nullable
              as Survey,
      interviewer: interviewer == freezed
          ? _value.interviewer
          : interviewer // ignore: cast_nullable_to_non_nullable
              as Interviewer,
      respondent: respondent == freezed
          ? _value.respondent
          : respondent // ignore: cast_nullable_to_non_nullable
              as Respondent,
      response: response == freezed
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as Response,
      responseMap: responseMap == freezed
          ? _value.responseMap
          : responseMap // ignore: cast_nullable_to_non_nullable
              as Map<UniqueId, Response>,
      referenceList: referenceList == freezed
          ? _value.referenceList
          : referenceList // ignore: cast_nullable_to_non_nullable
              as List<Reference>,
      moduleType: moduleType == freezed
          ? _value.moduleType
          : moduleType // ignore: cast_nullable_to_non_nullable
              as ModuleType,
      responseId: responseId == freezed
          ? _value.responseId
          : responseId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      mainResponse: mainResponse == freezed
          ? _value.mainResponse
          : mainResponse // ignore: cast_nullable_to_non_nullable
              as Response,
      questionMap: questionMap == freezed
          ? _value.questionMap
          : questionMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Question>,
      uploadResponseIdSet: uploadResponseIdSet == freezed
          ? _value.uploadResponseIdSet
          : uploadResponseIdSet // ignore: cast_nullable_to_non_nullable
              as Set<UniqueId>,
      downloadedResponseMap: downloadedResponseMap == freezed
          ? _value.downloadedResponseMap
          : downloadedResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<UniqueId, Response>,
      uploadResponseMap: uploadResponseMap == freezed
          ? _value.uploadResponseMap
          : uploadResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Map<String, dynamic>>,
      respondentResponseMap: respondentResponseMap == freezed
          ? _value.respondentResponseMap
          : respondentResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<ModuleType, Response>,
      dialogType: dialogType == freezed
          ? _value.dialogType
          : dialogType // ignore: cast_nullable_to_non_nullable
              as DialogType,
      networkType: networkType == freezed
          ? _value.networkType
          : networkType // ignore: cast_nullable_to_non_nullable
              as NetworkType,
      responseMapState: responseMapState == freezed
          ? _value.responseMapState
          : responseMapState // ignore: cast_nullable_to_non_nullable
              as LoadState,
      syncState: syncState == freezed
          ? _value.syncState
          : syncState // ignore: cast_nullable_to_non_nullable
              as SyncState,
      responseFailure: responseFailure == freezed
          ? _value.responseFailure
          : responseFailure // ignore: cast_nullable_to_non_nullable
              as Option<SurveyFailure>,
      eventState: eventState == freezed
          ? _value.eventState
          : eventState // ignore: cast_nullable_to_non_nullable
              as LoadState,
      updateState: updateState == freezed
          ? _value.updateState
          : updateState // ignore: cast_nullable_to_non_nullable
              as LoadState,
      updateParameters: updateParameters == freezed
          ? _value.updateParameters
          : updateParameters // ignore: cast_nullable_to_non_nullable
              as StateParameters,
      saveParameters: saveParameters == freezed
          ? _value.saveParameters
          : saveParameters // ignore: cast_nullable_to_non_nullable
              as StateParameters,
    ));
  }

  @override
  $UniqueIdCopyWith<$Res> get stateId {
    return $UniqueIdCopyWith<$Res>(_value.stateId, (value) {
      return _then(_value.copyWith(stateId: value));
    });
  }

  @override
  $SurveyCopyWith<$Res> get survey {
    return $SurveyCopyWith<$Res>(_value.survey, (value) {
      return _then(_value.copyWith(survey: value));
    });
  }

  @override
  $InterviewerCopyWith<$Res> get interviewer {
    return $InterviewerCopyWith<$Res>(_value.interviewer, (value) {
      return _then(_value.copyWith(interviewer: value));
    });
  }

  @override
  $RespondentCopyWith<$Res> get respondent {
    return $RespondentCopyWith<$Res>(_value.respondent, (value) {
      return _then(_value.copyWith(respondent: value));
    });
  }

  @override
  $ResponseCopyWith<$Res> get response {
    return $ResponseCopyWith<$Res>(_value.response, (value) {
      return _then(_value.copyWith(response: value));
    });
  }

  @override
  $ModuleTypeCopyWith<$Res> get moduleType {
    return $ModuleTypeCopyWith<$Res>(_value.moduleType, (value) {
      return _then(_value.copyWith(moduleType: value));
    });
  }

  @override
  $UniqueIdCopyWith<$Res> get responseId {
    return $UniqueIdCopyWith<$Res>(_value.responseId, (value) {
      return _then(_value.copyWith(responseId: value));
    });
  }

  @override
  $ResponseCopyWith<$Res> get mainResponse {
    return $ResponseCopyWith<$Res>(_value.mainResponse, (value) {
      return _then(_value.copyWith(mainResponse: value));
    });
  }

  @override
  $DialogTypeCopyWith<$Res> get dialogType {
    return $DialogTypeCopyWith<$Res>(_value.dialogType, (value) {
      return _then(_value.copyWith(dialogType: value));
    });
  }

  @override
  $NetworkTypeCopyWith<$Res> get networkType {
    return $NetworkTypeCopyWith<$Res>(_value.networkType, (value) {
      return _then(_value.copyWith(networkType: value));
    });
  }

  @override
  $LoadStateCopyWith<$Res> get responseMapState {
    return $LoadStateCopyWith<$Res>(_value.responseMapState, (value) {
      return _then(_value.copyWith(responseMapState: value));
    });
  }

  @override
  $SyncStateCopyWith<$Res> get syncState {
    return $SyncStateCopyWith<$Res>(_value.syncState, (value) {
      return _then(_value.copyWith(syncState: value));
    });
  }

  @override
  $LoadStateCopyWith<$Res> get eventState {
    return $LoadStateCopyWith<$Res>(_value.eventState, (value) {
      return _then(_value.copyWith(eventState: value));
    });
  }

  @override
  $LoadStateCopyWith<$Res> get updateState {
    return $LoadStateCopyWith<$Res>(_value.updateState, (value) {
      return _then(_value.copyWith(updateState: value));
    });
  }

  @override
  $StateParametersCopyWith<$Res> get updateParameters {
    return $StateParametersCopyWith<$Res>(_value.updateParameters, (value) {
      return _then(_value.copyWith(updateParameters: value));
    });
  }

  @override
  $StateParametersCopyWith<$Res> get saveParameters {
    return $StateParametersCopyWith<$Res>(_value.saveParameters, (value) {
      return _then(_value.copyWith(saveParameters: value));
    });
  }
}

/// @nodoc
abstract class _$$_ResponseStateCopyWith<$Res>
    implements $ResponseStateCopyWith<$Res> {
  factory _$$_ResponseStateCopyWith(
          _$_ResponseState value, $Res Function(_$_ResponseState) then) =
      __$$_ResponseStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {UniqueId stateId,
      Survey survey,
      Interviewer interviewer,
      Respondent respondent,
      Response response,
      Map<UniqueId, Response> responseMap,
      List<Reference> referenceList,
      ModuleType moduleType,
      UniqueId responseId,
      Response mainResponse,
      Map<String, Question> questionMap,
      Set<UniqueId> uploadResponseIdSet,
      Map<UniqueId, Response> downloadedResponseMap,
      Map<String, Map<String, dynamic>> uploadResponseMap,
      Map<ModuleType, Response> respondentResponseMap,
      DialogType dialogType,
      NetworkType networkType,
      LoadState responseMapState,
      SyncState syncState,
      Option<SurveyFailure> responseFailure,
      LoadState eventState,
      LoadState updateState,
      StateParameters updateParameters,
      StateParameters saveParameters});

  @override
  $UniqueIdCopyWith<$Res> get stateId;
  @override
  $SurveyCopyWith<$Res> get survey;
  @override
  $InterviewerCopyWith<$Res> get interviewer;
  @override
  $RespondentCopyWith<$Res> get respondent;
  @override
  $ResponseCopyWith<$Res> get response;
  @override
  $ModuleTypeCopyWith<$Res> get moduleType;
  @override
  $UniqueIdCopyWith<$Res> get responseId;
  @override
  $ResponseCopyWith<$Res> get mainResponse;
  @override
  $DialogTypeCopyWith<$Res> get dialogType;
  @override
  $NetworkTypeCopyWith<$Res> get networkType;
  @override
  $LoadStateCopyWith<$Res> get responseMapState;
  @override
  $SyncStateCopyWith<$Res> get syncState;
  @override
  $LoadStateCopyWith<$Res> get eventState;
  @override
  $LoadStateCopyWith<$Res> get updateState;
  @override
  $StateParametersCopyWith<$Res> get updateParameters;
  @override
  $StateParametersCopyWith<$Res> get saveParameters;
}

/// @nodoc
class __$$_ResponseStateCopyWithImpl<$Res>
    extends _$ResponseStateCopyWithImpl<$Res>
    implements _$$_ResponseStateCopyWith<$Res> {
  __$$_ResponseStateCopyWithImpl(
      _$_ResponseState _value, $Res Function(_$_ResponseState) _then)
      : super(_value, (v) => _then(v as _$_ResponseState));

  @override
  _$_ResponseState get _value => super._value as _$_ResponseState;

  @override
  $Res call({
    Object? stateId = freezed,
    Object? survey = freezed,
    Object? interviewer = freezed,
    Object? respondent = freezed,
    Object? response = freezed,
    Object? responseMap = freezed,
    Object? referenceList = freezed,
    Object? moduleType = freezed,
    Object? responseId = freezed,
    Object? mainResponse = freezed,
    Object? questionMap = freezed,
    Object? uploadResponseIdSet = freezed,
    Object? downloadedResponseMap = freezed,
    Object? uploadResponseMap = freezed,
    Object? respondentResponseMap = freezed,
    Object? dialogType = freezed,
    Object? networkType = freezed,
    Object? responseMapState = freezed,
    Object? syncState = freezed,
    Object? responseFailure = freezed,
    Object? eventState = freezed,
    Object? updateState = freezed,
    Object? updateParameters = freezed,
    Object? saveParameters = freezed,
  }) {
    return _then(_$_ResponseState(
      stateId: stateId == freezed
          ? _value.stateId
          : stateId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      survey: survey == freezed
          ? _value.survey
          : survey // ignore: cast_nullable_to_non_nullable
              as Survey,
      interviewer: interviewer == freezed
          ? _value.interviewer
          : interviewer // ignore: cast_nullable_to_non_nullable
              as Interviewer,
      respondent: respondent == freezed
          ? _value.respondent
          : respondent // ignore: cast_nullable_to_non_nullable
              as Respondent,
      response: response == freezed
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as Response,
      responseMap: responseMap == freezed
          ? _value._responseMap
          : responseMap // ignore: cast_nullable_to_non_nullable
              as Map<UniqueId, Response>,
      referenceList: referenceList == freezed
          ? _value._referenceList
          : referenceList // ignore: cast_nullable_to_non_nullable
              as List<Reference>,
      moduleType: moduleType == freezed
          ? _value.moduleType
          : moduleType // ignore: cast_nullable_to_non_nullable
              as ModuleType,
      responseId: responseId == freezed
          ? _value.responseId
          : responseId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      mainResponse: mainResponse == freezed
          ? _value.mainResponse
          : mainResponse // ignore: cast_nullable_to_non_nullable
              as Response,
      questionMap: questionMap == freezed
          ? _value._questionMap
          : questionMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Question>,
      uploadResponseIdSet: uploadResponseIdSet == freezed
          ? _value._uploadResponseIdSet
          : uploadResponseIdSet // ignore: cast_nullable_to_non_nullable
              as Set<UniqueId>,
      downloadedResponseMap: downloadedResponseMap == freezed
          ? _value._downloadedResponseMap
          : downloadedResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<UniqueId, Response>,
      uploadResponseMap: uploadResponseMap == freezed
          ? _value._uploadResponseMap
          : uploadResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<String, Map<String, dynamic>>,
      respondentResponseMap: respondentResponseMap == freezed
          ? _value._respondentResponseMap
          : respondentResponseMap // ignore: cast_nullable_to_non_nullable
              as Map<ModuleType, Response>,
      dialogType: dialogType == freezed
          ? _value.dialogType
          : dialogType // ignore: cast_nullable_to_non_nullable
              as DialogType,
      networkType: networkType == freezed
          ? _value.networkType
          : networkType // ignore: cast_nullable_to_non_nullable
              as NetworkType,
      responseMapState: responseMapState == freezed
          ? _value.responseMapState
          : responseMapState // ignore: cast_nullable_to_non_nullable
              as LoadState,
      syncState: syncState == freezed
          ? _value.syncState
          : syncState // ignore: cast_nullable_to_non_nullable
              as SyncState,
      responseFailure: responseFailure == freezed
          ? _value.responseFailure
          : responseFailure // ignore: cast_nullable_to_non_nullable
              as Option<SurveyFailure>,
      eventState: eventState == freezed
          ? _value.eventState
          : eventState // ignore: cast_nullable_to_non_nullable
              as LoadState,
      updateState: updateState == freezed
          ? _value.updateState
          : updateState // ignore: cast_nullable_to_non_nullable
              as LoadState,
      updateParameters: updateParameters == freezed
          ? _value.updateParameters
          : updateParameters // ignore: cast_nullable_to_non_nullable
              as StateParameters,
      saveParameters: saveParameters == freezed
          ? _value.saveParameters
          : saveParameters // ignore: cast_nullable_to_non_nullable
              as StateParameters,
    ));
  }
}

/// @nodoc

class _$_ResponseState extends _ResponseState with DiagnosticableTreeMixin {
  const _$_ResponseState(
      {required this.stateId,
      required this.survey,
      required this.interviewer,
      required this.respondent,
      required this.response,
      required final Map<UniqueId, Response> responseMap,
      required final List<Reference> referenceList,
      required this.moduleType,
      required this.responseId,
      required this.mainResponse,
      required final Map<String, Question> questionMap,
      required final Set<UniqueId> uploadResponseIdSet,
      required final Map<UniqueId, Response> downloadedResponseMap,
      required final Map<String, Map<String, dynamic>> uploadResponseMap,
      required final Map<ModuleType, Response> respondentResponseMap,
      required this.dialogType,
      required this.networkType,
      required this.responseMapState,
      required this.syncState,
      required this.responseFailure,
      required this.eventState,
      required this.updateState,
      required this.updateParameters,
      required this.saveParameters})
      : _responseMap = responseMap,
        _referenceList = referenceList,
        _questionMap = questionMap,
        _uploadResponseIdSet = uploadResponseIdSet,
        _downloadedResponseMap = downloadedResponseMap,
        _uploadResponseMap = uploadResponseMap,
        _respondentResponseMap = respondentResponseMap,
        super._();

  @override
  final UniqueId stateId;
// > 主要資料
  @override
  final Survey survey;
  @override
  final Interviewer interviewer;
  @override
  final Respondent respondent;
  @override
  final Response response;
  final Map<UniqueId, Response> _responseMap;
  @override
  Map<UniqueId, Response> get responseMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_responseMap);
  }

  final List<Reference> _referenceList;
  @override
  List<Reference> get referenceList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_referenceList);
  }

// > 中間資料
  @override
  final ModuleType moduleType;
  @override
  final UniqueId responseId;
  @override
  final Response mainResponse;
  final Map<String, Question> _questionMap;
  @override
  Map<String, Question> get questionMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_questionMap);
  }

  final Set<UniqueId> _uploadResponseIdSet;
  @override
  Set<UniqueId> get uploadResponseIdSet {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_uploadResponseIdSet);
  }

  final Map<UniqueId, Response> _downloadedResponseMap;
  @override
  Map<UniqueId, Response> get downloadedResponseMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_downloadedResponseMap);
  }

  final Map<String, Map<String, dynamic>> _uploadResponseMap;
  @override
  Map<String, Map<String, dynamic>> get uploadResponseMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_uploadResponseMap);
  }

  final Map<ModuleType, Response> _respondentResponseMap;
  @override
  Map<ModuleType, Response> get respondentResponseMap {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_respondentResponseMap);
  }

  @override
  final DialogType dialogType;
  @override
  final NetworkType networkType;
// > 狀態更新進度
  @override
  final LoadState responseMapState;
  @override
  final SyncState syncState;
  @override
  final Option<SurveyFailure> responseFailure;
  @override
  final LoadState eventState;
  @override
  final LoadState updateState;
// > 更新/儲存參數
  @override
  final StateParameters updateParameters;
  @override
  final StateParameters saveParameters;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseState(stateId: $stateId, survey: $survey, interviewer: $interviewer, respondent: $respondent, response: $response, responseMap: $responseMap, referenceList: $referenceList, moduleType: $moduleType, responseId: $responseId, mainResponse: $mainResponse, questionMap: $questionMap, uploadResponseIdSet: $uploadResponseIdSet, downloadedResponseMap: $downloadedResponseMap, uploadResponseMap: $uploadResponseMap, respondentResponseMap: $respondentResponseMap, dialogType: $dialogType, networkType: $networkType, responseMapState: $responseMapState, syncState: $syncState, responseFailure: $responseFailure, eventState: $eventState, updateState: $updateState, updateParameters: $updateParameters, saveParameters: $saveParameters)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseState'))
      ..add(DiagnosticsProperty('stateId', stateId))
      ..add(DiagnosticsProperty('survey', survey))
      ..add(DiagnosticsProperty('interviewer', interviewer))
      ..add(DiagnosticsProperty('respondent', respondent))
      ..add(DiagnosticsProperty('response', response))
      ..add(DiagnosticsProperty('responseMap', responseMap))
      ..add(DiagnosticsProperty('referenceList', referenceList))
      ..add(DiagnosticsProperty('moduleType', moduleType))
      ..add(DiagnosticsProperty('responseId', responseId))
      ..add(DiagnosticsProperty('mainResponse', mainResponse))
      ..add(DiagnosticsProperty('questionMap', questionMap))
      ..add(DiagnosticsProperty('uploadResponseIdSet', uploadResponseIdSet))
      ..add(DiagnosticsProperty('downloadedResponseMap', downloadedResponseMap))
      ..add(DiagnosticsProperty('uploadResponseMap', uploadResponseMap))
      ..add(DiagnosticsProperty('respondentResponseMap', respondentResponseMap))
      ..add(DiagnosticsProperty('dialogType', dialogType))
      ..add(DiagnosticsProperty('networkType', networkType))
      ..add(DiagnosticsProperty('responseMapState', responseMapState))
      ..add(DiagnosticsProperty('syncState', syncState))
      ..add(DiagnosticsProperty('responseFailure', responseFailure))
      ..add(DiagnosticsProperty('eventState', eventState))
      ..add(DiagnosticsProperty('updateState', updateState))
      ..add(DiagnosticsProperty('updateParameters', updateParameters))
      ..add(DiagnosticsProperty('saveParameters', saveParameters));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseState &&
            const DeepCollectionEquality().equals(other.stateId, stateId) &&
            const DeepCollectionEquality().equals(other.survey, survey) &&
            const DeepCollectionEquality()
                .equals(other.interviewer, interviewer) &&
            const DeepCollectionEquality()
                .equals(other.respondent, respondent) &&
            const DeepCollectionEquality().equals(other.response, response) &&
            const DeepCollectionEquality()
                .equals(other._responseMap, _responseMap) &&
            const DeepCollectionEquality()
                .equals(other._referenceList, _referenceList) &&
            const DeepCollectionEquality()
                .equals(other.moduleType, moduleType) &&
            const DeepCollectionEquality()
                .equals(other.responseId, responseId) &&
            const DeepCollectionEquality()
                .equals(other.mainResponse, mainResponse) &&
            const DeepCollectionEquality()
                .equals(other._questionMap, _questionMap) &&
            const DeepCollectionEquality()
                .equals(other._uploadResponseIdSet, _uploadResponseIdSet) &&
            const DeepCollectionEquality()
                .equals(other._downloadedResponseMap, _downloadedResponseMap) &&
            const DeepCollectionEquality()
                .equals(other._uploadResponseMap, _uploadResponseMap) &&
            const DeepCollectionEquality()
                .equals(other._respondentResponseMap, _respondentResponseMap) &&
            const DeepCollectionEquality()
                .equals(other.dialogType, dialogType) &&
            const DeepCollectionEquality()
                .equals(other.networkType, networkType) &&
            const DeepCollectionEquality()
                .equals(other.responseMapState, responseMapState) &&
            const DeepCollectionEquality().equals(other.syncState, syncState) &&
            const DeepCollectionEquality()
                .equals(other.responseFailure, responseFailure) &&
            const DeepCollectionEquality()
                .equals(other.eventState, eventState) &&
            const DeepCollectionEquality()
                .equals(other.updateState, updateState) &&
            const DeepCollectionEquality()
                .equals(other.updateParameters, updateParameters) &&
            const DeepCollectionEquality()
                .equals(other.saveParameters, saveParameters));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        const DeepCollectionEquality().hash(stateId),
        const DeepCollectionEquality().hash(survey),
        const DeepCollectionEquality().hash(interviewer),
        const DeepCollectionEquality().hash(respondent),
        const DeepCollectionEquality().hash(response),
        const DeepCollectionEquality().hash(_responseMap),
        const DeepCollectionEquality().hash(_referenceList),
        const DeepCollectionEquality().hash(moduleType),
        const DeepCollectionEquality().hash(responseId),
        const DeepCollectionEquality().hash(mainResponse),
        const DeepCollectionEquality().hash(_questionMap),
        const DeepCollectionEquality().hash(_uploadResponseIdSet),
        const DeepCollectionEquality().hash(_downloadedResponseMap),
        const DeepCollectionEquality().hash(_uploadResponseMap),
        const DeepCollectionEquality().hash(_respondentResponseMap),
        const DeepCollectionEquality().hash(dialogType),
        const DeepCollectionEquality().hash(networkType),
        const DeepCollectionEquality().hash(responseMapState),
        const DeepCollectionEquality().hash(syncState),
        const DeepCollectionEquality().hash(responseFailure),
        const DeepCollectionEquality().hash(eventState),
        const DeepCollectionEquality().hash(updateState),
        const DeepCollectionEquality().hash(updateParameters),
        const DeepCollectionEquality().hash(saveParameters)
      ]);

  @JsonKey(ignore: true)
  @override
  _$$_ResponseStateCopyWith<_$_ResponseState> get copyWith =>
      __$$_ResponseStateCopyWithImpl<_$_ResponseState>(this, _$identity);
}

abstract class _ResponseState extends ResponseState {
  const factory _ResponseState(
      {required final UniqueId stateId,
      required final Survey survey,
      required final Interviewer interviewer,
      required final Respondent respondent,
      required final Response response,
      required final Map<UniqueId, Response> responseMap,
      required final List<Reference> referenceList,
      required final ModuleType moduleType,
      required final UniqueId responseId,
      required final Response mainResponse,
      required final Map<String, Question> questionMap,
      required final Set<UniqueId> uploadResponseIdSet,
      required final Map<UniqueId, Response> downloadedResponseMap,
      required final Map<String, Map<String, dynamic>> uploadResponseMap,
      required final Map<ModuleType, Response> respondentResponseMap,
      required final DialogType dialogType,
      required final NetworkType networkType,
      required final LoadState responseMapState,
      required final SyncState syncState,
      required final Option<SurveyFailure> responseFailure,
      required final LoadState eventState,
      required final LoadState updateState,
      required final StateParameters updateParameters,
      required final StateParameters saveParameters}) = _$_ResponseState;
  const _ResponseState._() : super._();

  @override
  UniqueId get stateId => throw _privateConstructorUsedError;
  @override // > 主要資料
  Survey get survey => throw _privateConstructorUsedError;
  @override
  Interviewer get interviewer => throw _privateConstructorUsedError;
  @override
  Respondent get respondent => throw _privateConstructorUsedError;
  @override
  Response get response => throw _privateConstructorUsedError;
  @override
  Map<UniqueId, Response> get responseMap => throw _privateConstructorUsedError;
  @override
  List<Reference> get referenceList => throw _privateConstructorUsedError;
  @override // > 中間資料
  ModuleType get moduleType => throw _privateConstructorUsedError;
  @override
  UniqueId get responseId => throw _privateConstructorUsedError;
  @override
  Response get mainResponse => throw _privateConstructorUsedError;
  @override
  Map<String, Question> get questionMap => throw _privateConstructorUsedError;
  @override
  Set<UniqueId> get uploadResponseIdSet => throw _privateConstructorUsedError;
  @override
  Map<UniqueId, Response> get downloadedResponseMap =>
      throw _privateConstructorUsedError;
  @override
  Map<String, Map<String, dynamic>> get uploadResponseMap =>
      throw _privateConstructorUsedError;
  @override
  Map<ModuleType, Response> get respondentResponseMap =>
      throw _privateConstructorUsedError;
  @override
  DialogType get dialogType => throw _privateConstructorUsedError;
  @override
  NetworkType get networkType => throw _privateConstructorUsedError;
  @override // > 狀態更新進度
  LoadState get responseMapState => throw _privateConstructorUsedError;
  @override
  SyncState get syncState => throw _privateConstructorUsedError;
  @override
  Option<SurveyFailure> get responseFailure =>
      throw _privateConstructorUsedError;
  @override
  LoadState get eventState => throw _privateConstructorUsedError;
  @override
  LoadState get updateState => throw _privateConstructorUsedError;
  @override // > 更新/儲存參數
  StateParameters get updateParameters => throw _privateConstructorUsedError;
  @override
  StateParameters get saveParameters => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ResponseStateCopyWith<_$_ResponseState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StateParameters {
// > 共用
  bool get referenceList => throw _privateConstructorUsedError;
  bool get response => throw _privateConstructorUsedError; // > 儲存
  bool get survey => throw _privateConstructorUsedError;
  bool get interviewer => throw _privateConstructorUsedError;
  bool get respondent => throw _privateConstructorUsedError;
  bool get responseMap => throw _privateConstructorUsedError;
  Set<UniqueId> get responseMapKeys => throw _privateConstructorUsedError;
  bool get uploadResponseIdSet => throw _privateConstructorUsedError; // > 更新
  bool get visitReportsMap => throw _privateConstructorUsedError;
  bool get housingMap => throw _privateConstructorUsedError;
  bool get respondentResponseMap => throw _privateConstructorUsedError;
  bool get tabRespondentMap => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StateParametersCopyWith<StateParameters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StateParametersCopyWith<$Res> {
  factory $StateParametersCopyWith(
          StateParameters value, $Res Function(StateParameters) then) =
      _$StateParametersCopyWithImpl<$Res>;
  $Res call(
      {bool referenceList,
      bool response,
      bool survey,
      bool interviewer,
      bool respondent,
      bool responseMap,
      Set<UniqueId> responseMapKeys,
      bool uploadResponseIdSet,
      bool visitReportsMap,
      bool housingMap,
      bool respondentResponseMap,
      bool tabRespondentMap});
}

/// @nodoc
class _$StateParametersCopyWithImpl<$Res>
    implements $StateParametersCopyWith<$Res> {
  _$StateParametersCopyWithImpl(this._value, this._then);

  final StateParameters _value;
  // ignore: unused_field
  final $Res Function(StateParameters) _then;

  @override
  $Res call({
    Object? referenceList = freezed,
    Object? response = freezed,
    Object? survey = freezed,
    Object? interviewer = freezed,
    Object? respondent = freezed,
    Object? responseMap = freezed,
    Object? responseMapKeys = freezed,
    Object? uploadResponseIdSet = freezed,
    Object? visitReportsMap = freezed,
    Object? housingMap = freezed,
    Object? respondentResponseMap = freezed,
    Object? tabRespondentMap = freezed,
  }) {
    return _then(_value.copyWith(
      referenceList: referenceList == freezed
          ? _value.referenceList
          : referenceList // ignore: cast_nullable_to_non_nullable
              as bool,
      response: response == freezed
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as bool,
      survey: survey == freezed
          ? _value.survey
          : survey // ignore: cast_nullable_to_non_nullable
              as bool,
      interviewer: interviewer == freezed
          ? _value.interviewer
          : interviewer // ignore: cast_nullable_to_non_nullable
              as bool,
      respondent: respondent == freezed
          ? _value.respondent
          : respondent // ignore: cast_nullable_to_non_nullable
              as bool,
      responseMap: responseMap == freezed
          ? _value.responseMap
          : responseMap // ignore: cast_nullable_to_non_nullable
              as bool,
      responseMapKeys: responseMapKeys == freezed
          ? _value.responseMapKeys
          : responseMapKeys // ignore: cast_nullable_to_non_nullable
              as Set<UniqueId>,
      uploadResponseIdSet: uploadResponseIdSet == freezed
          ? _value.uploadResponseIdSet
          : uploadResponseIdSet // ignore: cast_nullable_to_non_nullable
              as bool,
      visitReportsMap: visitReportsMap == freezed
          ? _value.visitReportsMap
          : visitReportsMap // ignore: cast_nullable_to_non_nullable
              as bool,
      housingMap: housingMap == freezed
          ? _value.housingMap
          : housingMap // ignore: cast_nullable_to_non_nullable
              as bool,
      respondentResponseMap: respondentResponseMap == freezed
          ? _value.respondentResponseMap
          : respondentResponseMap // ignore: cast_nullable_to_non_nullable
              as bool,
      tabRespondentMap: tabRespondentMap == freezed
          ? _value.tabRespondentMap
          : tabRespondentMap // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_StateParametersCopyWith<$Res>
    implements $StateParametersCopyWith<$Res> {
  factory _$$_StateParametersCopyWith(
          _$_StateParameters value, $Res Function(_$_StateParameters) then) =
      __$$_StateParametersCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool referenceList,
      bool response,
      bool survey,
      bool interviewer,
      bool respondent,
      bool responseMap,
      Set<UniqueId> responseMapKeys,
      bool uploadResponseIdSet,
      bool visitReportsMap,
      bool housingMap,
      bool respondentResponseMap,
      bool tabRespondentMap});
}

/// @nodoc
class __$$_StateParametersCopyWithImpl<$Res>
    extends _$StateParametersCopyWithImpl<$Res>
    implements _$$_StateParametersCopyWith<$Res> {
  __$$_StateParametersCopyWithImpl(
      _$_StateParameters _value, $Res Function(_$_StateParameters) _then)
      : super(_value, (v) => _then(v as _$_StateParameters));

  @override
  _$_StateParameters get _value => super._value as _$_StateParameters;

  @override
  $Res call({
    Object? referenceList = freezed,
    Object? response = freezed,
    Object? survey = freezed,
    Object? interviewer = freezed,
    Object? respondent = freezed,
    Object? responseMap = freezed,
    Object? responseMapKeys = freezed,
    Object? uploadResponseIdSet = freezed,
    Object? visitReportsMap = freezed,
    Object? housingMap = freezed,
    Object? respondentResponseMap = freezed,
    Object? tabRespondentMap = freezed,
  }) {
    return _then(_$_StateParameters(
      referenceList: referenceList == freezed
          ? _value.referenceList
          : referenceList // ignore: cast_nullable_to_non_nullable
              as bool,
      response: response == freezed
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as bool,
      survey: survey == freezed
          ? _value.survey
          : survey // ignore: cast_nullable_to_non_nullable
              as bool,
      interviewer: interviewer == freezed
          ? _value.interviewer
          : interviewer // ignore: cast_nullable_to_non_nullable
              as bool,
      respondent: respondent == freezed
          ? _value.respondent
          : respondent // ignore: cast_nullable_to_non_nullable
              as bool,
      responseMap: responseMap == freezed
          ? _value.responseMap
          : responseMap // ignore: cast_nullable_to_non_nullable
              as bool,
      responseMapKeys: responseMapKeys == freezed
          ? _value._responseMapKeys
          : responseMapKeys // ignore: cast_nullable_to_non_nullable
              as Set<UniqueId>,
      uploadResponseIdSet: uploadResponseIdSet == freezed
          ? _value.uploadResponseIdSet
          : uploadResponseIdSet // ignore: cast_nullable_to_non_nullable
              as bool,
      visitReportsMap: visitReportsMap == freezed
          ? _value.visitReportsMap
          : visitReportsMap // ignore: cast_nullable_to_non_nullable
              as bool,
      housingMap: housingMap == freezed
          ? _value.housingMap
          : housingMap // ignore: cast_nullable_to_non_nullable
              as bool,
      respondentResponseMap: respondentResponseMap == freezed
          ? _value.respondentResponseMap
          : respondentResponseMap // ignore: cast_nullable_to_non_nullable
              as bool,
      tabRespondentMap: tabRespondentMap == freezed
          ? _value.tabRespondentMap
          : tabRespondentMap // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_StateParameters extends _StateParameters with DiagnosticableTreeMixin {
  const _$_StateParameters(
      {required this.referenceList,
      required this.response,
      required this.survey,
      required this.interviewer,
      required this.respondent,
      required this.responseMap,
      required final Set<UniqueId> responseMapKeys,
      required this.uploadResponseIdSet,
      required this.visitReportsMap,
      required this.housingMap,
      required this.respondentResponseMap,
      required this.tabRespondentMap})
      : _responseMapKeys = responseMapKeys,
        super._();

// > 共用
  @override
  final bool referenceList;
  @override
  final bool response;
// > 儲存
  @override
  final bool survey;
  @override
  final bool interviewer;
  @override
  final bool respondent;
  @override
  final bool responseMap;
  final Set<UniqueId> _responseMapKeys;
  @override
  Set<UniqueId> get responseMapKeys {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_responseMapKeys);
  }

  @override
  final bool uploadResponseIdSet;
// > 更新
  @override
  final bool visitReportsMap;
  @override
  final bool housingMap;
  @override
  final bool respondentResponseMap;
  @override
  final bool tabRespondentMap;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StateParameters(referenceList: $referenceList, response: $response, survey: $survey, interviewer: $interviewer, respondent: $respondent, responseMap: $responseMap, responseMapKeys: $responseMapKeys, uploadResponseIdSet: $uploadResponseIdSet, visitReportsMap: $visitReportsMap, housingMap: $housingMap, respondentResponseMap: $respondentResponseMap, tabRespondentMap: $tabRespondentMap)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'StateParameters'))
      ..add(DiagnosticsProperty('referenceList', referenceList))
      ..add(DiagnosticsProperty('response', response))
      ..add(DiagnosticsProperty('survey', survey))
      ..add(DiagnosticsProperty('interviewer', interviewer))
      ..add(DiagnosticsProperty('respondent', respondent))
      ..add(DiagnosticsProperty('responseMap', responseMap))
      ..add(DiagnosticsProperty('responseMapKeys', responseMapKeys))
      ..add(DiagnosticsProperty('uploadResponseIdSet', uploadResponseIdSet))
      ..add(DiagnosticsProperty('visitReportsMap', visitReportsMap))
      ..add(DiagnosticsProperty('housingMap', housingMap))
      ..add(DiagnosticsProperty('respondentResponseMap', respondentResponseMap))
      ..add(DiagnosticsProperty('tabRespondentMap', tabRespondentMap));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StateParameters &&
            const DeepCollectionEquality()
                .equals(other.referenceList, referenceList) &&
            const DeepCollectionEquality().equals(other.response, response) &&
            const DeepCollectionEquality().equals(other.survey, survey) &&
            const DeepCollectionEquality()
                .equals(other.interviewer, interviewer) &&
            const DeepCollectionEquality()
                .equals(other.respondent, respondent) &&
            const DeepCollectionEquality()
                .equals(other.responseMap, responseMap) &&
            const DeepCollectionEquality()
                .equals(other._responseMapKeys, _responseMapKeys) &&
            const DeepCollectionEquality()
                .equals(other.uploadResponseIdSet, uploadResponseIdSet) &&
            const DeepCollectionEquality()
                .equals(other.visitReportsMap, visitReportsMap) &&
            const DeepCollectionEquality()
                .equals(other.housingMap, housingMap) &&
            const DeepCollectionEquality()
                .equals(other.respondentResponseMap, respondentResponseMap) &&
            const DeepCollectionEquality()
                .equals(other.tabRespondentMap, tabRespondentMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(referenceList),
      const DeepCollectionEquality().hash(response),
      const DeepCollectionEquality().hash(survey),
      const DeepCollectionEquality().hash(interviewer),
      const DeepCollectionEquality().hash(respondent),
      const DeepCollectionEquality().hash(responseMap),
      const DeepCollectionEquality().hash(_responseMapKeys),
      const DeepCollectionEquality().hash(uploadResponseIdSet),
      const DeepCollectionEquality().hash(visitReportsMap),
      const DeepCollectionEquality().hash(housingMap),
      const DeepCollectionEquality().hash(respondentResponseMap),
      const DeepCollectionEquality().hash(tabRespondentMap));

  @JsonKey(ignore: true)
  @override
  _$$_StateParametersCopyWith<_$_StateParameters> get copyWith =>
      __$$_StateParametersCopyWithImpl<_$_StateParameters>(this, _$identity);
}

abstract class _StateParameters extends StateParameters {
  const factory _StateParameters(
      {required final bool referenceList,
      required final bool response,
      required final bool survey,
      required final bool interviewer,
      required final bool respondent,
      required final bool responseMap,
      required final Set<UniqueId> responseMapKeys,
      required final bool uploadResponseIdSet,
      required final bool visitReportsMap,
      required final bool housingMap,
      required final bool respondentResponseMap,
      required final bool tabRespondentMap}) = _$_StateParameters;
  const _StateParameters._() : super._();

  @override // > 共用
  bool get referenceList => throw _privateConstructorUsedError;
  @override
  bool get response => throw _privateConstructorUsedError;
  @override // > 儲存
  bool get survey => throw _privateConstructorUsedError;
  @override
  bool get interviewer => throw _privateConstructorUsedError;
  @override
  bool get respondent => throw _privateConstructorUsedError;
  @override
  bool get responseMap => throw _privateConstructorUsedError;
  @override
  Set<UniqueId> get responseMapKeys => throw _privateConstructorUsedError;
  @override
  bool get uploadResponseIdSet => throw _privateConstructorUsedError;
  @override // > 更新
  bool get visitReportsMap => throw _privateConstructorUsedError;
  @override
  bool get housingMap => throw _privateConstructorUsedError;
  @override
  bool get respondentResponseMap => throw _privateConstructorUsedError;
  @override
  bool get tabRespondentMap => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_StateParametersCopyWith<_$_StateParameters> get copyWith =>
      throw _privateConstructorUsedError;
}
