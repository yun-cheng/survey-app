// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'value_objects.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FormatType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FormatTypeCopyWith<FormatType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormatTypeCopyWith<$Res> {
  factory $FormatTypeCopyWith(
          FormatType value, $Res Function(FormatType) then) =
      _$FormatTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$FormatTypeCopyWithImpl<$Res> implements $FormatTypeCopyWith<$Res> {
  _$FormatTypeCopyWithImpl(this._value, this._then);

  final FormatType _value;
  // ignore: unused_field
  final $Res Function(FormatType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_FormatTypeCopyWith<$Res>
    implements $FormatTypeCopyWith<$Res> {
  factory _$$_FormatTypeCopyWith(
          _$_FormatType value, $Res Function(_$_FormatType) then) =
      __$$_FormatTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_FormatTypeCopyWithImpl<$Res> extends _$FormatTypeCopyWithImpl<$Res>
    implements _$$_FormatTypeCopyWith<$Res> {
  __$$_FormatTypeCopyWithImpl(
      _$_FormatType _value, $Res Function(_$_FormatType) _then)
      : super(_value, (v) => _then(v as _$_FormatType));

  @override
  _$_FormatType get _value => super._value as _$_FormatType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_FormatType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_FormatType extends _FormatType {
  const _$_FormatType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'FormatType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FormatType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_FormatTypeCopyWith<_$_FormatType> get copyWith =>
      __$$_FormatTypeCopyWithImpl<_$_FormatType>(this, _$identity);
}

abstract class _FormatType extends FormatType {
  const factory _FormatType(final String value) = _$_FormatType;
  const _FormatType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_FormatTypeCopyWith<_$_FormatType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$QuestionType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $QuestionTypeCopyWith<QuestionType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionTypeCopyWith<$Res> {
  factory $QuestionTypeCopyWith(
          QuestionType value, $Res Function(QuestionType) then) =
      _$QuestionTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$QuestionTypeCopyWithImpl<$Res> implements $QuestionTypeCopyWith<$Res> {
  _$QuestionTypeCopyWithImpl(this._value, this._then);

  final QuestionType _value;
  // ignore: unused_field
  final $Res Function(QuestionType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_QuestionTypeCopyWith<$Res>
    implements $QuestionTypeCopyWith<$Res> {
  factory _$$_QuestionTypeCopyWith(
          _$_QuestionType value, $Res Function(_$_QuestionType) then) =
      __$$_QuestionTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_QuestionTypeCopyWithImpl<$Res>
    extends _$QuestionTypeCopyWithImpl<$Res>
    implements _$$_QuestionTypeCopyWith<$Res> {
  __$$_QuestionTypeCopyWithImpl(
      _$_QuestionType _value, $Res Function(_$_QuestionType) _then)
      : super(_value, (v) => _then(v as _$_QuestionType));

  @override
  _$_QuestionType get _value => super._value as _$_QuestionType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_QuestionType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_QuestionType extends _QuestionType {
  const _$_QuestionType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'QuestionType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QuestionType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_QuestionTypeCopyWith<_$_QuestionType> get copyWith =>
      __$$_QuestionTypeCopyWithImpl<_$_QuestionType>(this, _$identity);
}

abstract class _QuestionType extends QuestionType {
  const factory _QuestionType(final String value) = _$_QuestionType;
  const _QuestionType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_QuestionTypeCopyWith<_$_QuestionType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnswerType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerTypeCopyWith<AnswerType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerTypeCopyWith<$Res> {
  factory $AnswerTypeCopyWith(
          AnswerType value, $Res Function(AnswerType) then) =
      _$AnswerTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$AnswerTypeCopyWithImpl<$Res> implements $AnswerTypeCopyWith<$Res> {
  _$AnswerTypeCopyWithImpl(this._value, this._then);

  final AnswerType _value;
  // ignore: unused_field
  final $Res Function(AnswerType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_AnswerTypeCopyWith<$Res>
    implements $AnswerTypeCopyWith<$Res> {
  factory _$$_AnswerTypeCopyWith(
          _$_AnswerType value, $Res Function(_$_AnswerType) then) =
      __$$_AnswerTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_AnswerTypeCopyWithImpl<$Res> extends _$AnswerTypeCopyWithImpl<$Res>
    implements _$$_AnswerTypeCopyWith<$Res> {
  __$$_AnswerTypeCopyWithImpl(
      _$_AnswerType _value, $Res Function(_$_AnswerType) _then)
      : super(_value, (v) => _then(v as _$_AnswerType));

  @override
  _$_AnswerType get _value => super._value as _$_AnswerType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_AnswerType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_AnswerType extends _AnswerType {
  const _$_AnswerType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'AnswerType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnswerType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_AnswerTypeCopyWith<_$_AnswerType> get copyWith =>
      __$$_AnswerTypeCopyWithImpl<_$_AnswerType>(this, _$identity);
}

abstract class _AnswerType extends AnswerType {
  const factory _AnswerType(final String value) = _$_AnswerType;
  const _AnswerType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_AnswerTypeCopyWith<_$_AnswerType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnswerStatusType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerStatusTypeCopyWith<AnswerStatusType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerStatusTypeCopyWith<$Res> {
  factory $AnswerStatusTypeCopyWith(
          AnswerStatusType value, $Res Function(AnswerStatusType) then) =
      _$AnswerStatusTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$AnswerStatusTypeCopyWithImpl<$Res>
    implements $AnswerStatusTypeCopyWith<$Res> {
  _$AnswerStatusTypeCopyWithImpl(this._value, this._then);

  final AnswerStatusType _value;
  // ignore: unused_field
  final $Res Function(AnswerStatusType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_AnswerStatusTypeCopyWith<$Res>
    implements $AnswerStatusTypeCopyWith<$Res> {
  factory _$$_AnswerStatusTypeCopyWith(
          _$_AnswerStatusType value, $Res Function(_$_AnswerStatusType) then) =
      __$$_AnswerStatusTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_AnswerStatusTypeCopyWithImpl<$Res>
    extends _$AnswerStatusTypeCopyWithImpl<$Res>
    implements _$$_AnswerStatusTypeCopyWith<$Res> {
  __$$_AnswerStatusTypeCopyWithImpl(
      _$_AnswerStatusType _value, $Res Function(_$_AnswerStatusType) _then)
      : super(_value, (v) => _then(v as _$_AnswerStatusType));

  @override
  _$_AnswerStatusType get _value => super._value as _$_AnswerStatusType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_AnswerStatusType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_AnswerStatusType extends _AnswerStatusType {
  const _$_AnswerStatusType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'AnswerStatusType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnswerStatusType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_AnswerStatusTypeCopyWith<_$_AnswerStatusType> get copyWith =>
      __$$_AnswerStatusTypeCopyWithImpl<_$_AnswerStatusType>(this, _$identity);
}

abstract class _AnswerStatusType extends AnswerStatusType {
  const factory _AnswerStatusType(final String value) = _$_AnswerStatusType;
  const _AnswerStatusType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_AnswerStatusTypeCopyWith<_$_AnswerStatusType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WarningType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WarningTypeCopyWith<WarningType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarningTypeCopyWith<$Res> {
  factory $WarningTypeCopyWith(
          WarningType value, $Res Function(WarningType) then) =
      _$WarningTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$WarningTypeCopyWithImpl<$Res> implements $WarningTypeCopyWith<$Res> {
  _$WarningTypeCopyWithImpl(this._value, this._then);

  final WarningType _value;
  // ignore: unused_field
  final $Res Function(WarningType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_WarningTypeCopyWith<$Res>
    implements $WarningTypeCopyWith<$Res> {
  factory _$$_WarningTypeCopyWith(
          _$_WarningType value, $Res Function(_$_WarningType) then) =
      __$$_WarningTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_WarningTypeCopyWithImpl<$Res> extends _$WarningTypeCopyWithImpl<$Res>
    implements _$$_WarningTypeCopyWith<$Res> {
  __$$_WarningTypeCopyWithImpl(
      _$_WarningType _value, $Res Function(_$_WarningType) _then)
      : super(_value, (v) => _then(v as _$_WarningType));

  @override
  _$_WarningType get _value => super._value as _$_WarningType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_WarningType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_WarningType extends _WarningType {
  const _$_WarningType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'WarningType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WarningType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_WarningTypeCopyWith<_$_WarningType> get copyWith =>
      __$$_WarningTypeCopyWithImpl<_$_WarningType>(this, _$identity);
}

abstract class _WarningType extends WarningType {
  const factory _WarningType(final String value) = _$_WarningType;
  const _WarningType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_WarningTypeCopyWith<_$_WarningType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Operator {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OperatorCopyWith<Operator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperatorCopyWith<$Res> {
  factory $OperatorCopyWith(Operator value, $Res Function(Operator) then) =
      _$OperatorCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$OperatorCopyWithImpl<$Res> implements $OperatorCopyWith<$Res> {
  _$OperatorCopyWithImpl(this._value, this._then);

  final Operator _value;
  // ignore: unused_field
  final $Res Function(Operator) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_OperatorCopyWith<$Res> implements $OperatorCopyWith<$Res> {
  factory _$$_OperatorCopyWith(
          _$_Operator value, $Res Function(_$_Operator) then) =
      __$$_OperatorCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_OperatorCopyWithImpl<$Res> extends _$OperatorCopyWithImpl<$Res>
    implements _$$_OperatorCopyWith<$Res> {
  __$$_OperatorCopyWithImpl(
      _$_Operator _value, $Res Function(_$_Operator) _then)
      : super(_value, (v) => _then(v as _$_Operator));

  @override
  _$_Operator get _value => super._value as _$_Operator;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_Operator(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Operator extends _Operator {
  const _$_Operator(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'Operator(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Operator &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_OperatorCopyWith<_$_Operator> get copyWith =>
      __$$_OperatorCopyWithImpl<_$_Operator>(this, _$identity);
}

abstract class _Operator extends Operator {
  const factory _Operator(final String value) = _$_Operator;
  const _Operator._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_OperatorCopyWith<_$_Operator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ModuleType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModuleTypeCopyWith<ModuleType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModuleTypeCopyWith<$Res> {
  factory $ModuleTypeCopyWith(
          ModuleType value, $Res Function(ModuleType) then) =
      _$ModuleTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$ModuleTypeCopyWithImpl<$Res> implements $ModuleTypeCopyWith<$Res> {
  _$ModuleTypeCopyWithImpl(this._value, this._then);

  final ModuleType _value;
  // ignore: unused_field
  final $Res Function(ModuleType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_ModuleTypeCopyWith<$Res>
    implements $ModuleTypeCopyWith<$Res> {
  factory _$$_ModuleTypeCopyWith(
          _$_ModuleType value, $Res Function(_$_ModuleType) then) =
      __$$_ModuleTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_ModuleTypeCopyWithImpl<$Res> extends _$ModuleTypeCopyWithImpl<$Res>
    implements _$$_ModuleTypeCopyWith<$Res> {
  __$$_ModuleTypeCopyWithImpl(
      _$_ModuleType _value, $Res Function(_$_ModuleType) _then)
      : super(_value, (v) => _then(v as _$_ModuleType));

  @override
  _$_ModuleType get _value => super._value as _$_ModuleType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_ModuleType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ModuleType extends _ModuleType {
  const _$_ModuleType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'ModuleType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ModuleType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_ModuleTypeCopyWith<_$_ModuleType> get copyWith =>
      __$$_ModuleTypeCopyWithImpl<_$_ModuleType>(this, _$identity);
}

abstract class _ModuleType extends ModuleType {
  const factory _ModuleType(final String value) = _$_ModuleType;
  const _ModuleType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_ModuleTypeCopyWith<_$_ModuleType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ResponseStatus {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ResponseStatusCopyWith<ResponseStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseStatusCopyWith<$Res> {
  factory $ResponseStatusCopyWith(
          ResponseStatus value, $Res Function(ResponseStatus) then) =
      _$ResponseStatusCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$ResponseStatusCopyWithImpl<$Res>
    implements $ResponseStatusCopyWith<$Res> {
  _$ResponseStatusCopyWithImpl(this._value, this._then);

  final ResponseStatus _value;
  // ignore: unused_field
  final $Res Function(ResponseStatus) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_ResponseStatusCopyWith<$Res>
    implements $ResponseStatusCopyWith<$Res> {
  factory _$$_ResponseStatusCopyWith(
          _$_ResponseStatus value, $Res Function(_$_ResponseStatus) then) =
      __$$_ResponseStatusCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_ResponseStatusCopyWithImpl<$Res>
    extends _$ResponseStatusCopyWithImpl<$Res>
    implements _$$_ResponseStatusCopyWith<$Res> {
  __$$_ResponseStatusCopyWithImpl(
      _$_ResponseStatus _value, $Res Function(_$_ResponseStatus) _then)
      : super(_value, (v) => _then(v as _$_ResponseStatus));

  @override
  _$_ResponseStatus get _value => super._value as _$_ResponseStatus;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_ResponseStatus(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ResponseStatus extends _ResponseStatus {
  const _$_ResponseStatus(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'ResponseStatus(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseStatus &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseStatusCopyWith<_$_ResponseStatus> get copyWith =>
      __$$_ResponseStatusCopyWithImpl<_$_ResponseStatus>(this, _$identity);
}

abstract class _ResponseStatus extends ResponseStatus {
  const factory _ResponseStatus(final String value) = _$_ResponseStatus;
  const _ResponseStatus._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_ResponseStatusCopyWith<_$_ResponseStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DeviceTimeStamp {
  DateTime get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeviceTimeStampCopyWith<DeviceTimeStamp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceTimeStampCopyWith<$Res> {
  factory $DeviceTimeStampCopyWith(
          DeviceTimeStamp value, $Res Function(DeviceTimeStamp) then) =
      _$DeviceTimeStampCopyWithImpl<$Res>;
  $Res call({DateTime value});
}

/// @nodoc
class _$DeviceTimeStampCopyWithImpl<$Res>
    implements $DeviceTimeStampCopyWith<$Res> {
  _$DeviceTimeStampCopyWithImpl(this._value, this._then);

  final DeviceTimeStamp _value;
  // ignore: unused_field
  final $Res Function(DeviceTimeStamp) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$$_DeviceTimeStampCopyWith<$Res>
    implements $DeviceTimeStampCopyWith<$Res> {
  factory _$$_DeviceTimeStampCopyWith(
          _$_DeviceTimeStamp value, $Res Function(_$_DeviceTimeStamp) then) =
      __$$_DeviceTimeStampCopyWithImpl<$Res>;
  @override
  $Res call({DateTime value});
}

/// @nodoc
class __$$_DeviceTimeStampCopyWithImpl<$Res>
    extends _$DeviceTimeStampCopyWithImpl<$Res>
    implements _$$_DeviceTimeStampCopyWith<$Res> {
  __$$_DeviceTimeStampCopyWithImpl(
      _$_DeviceTimeStamp _value, $Res Function(_$_DeviceTimeStamp) _then)
      : super(_value, (v) => _then(v as _$_DeviceTimeStamp));

  @override
  _$_DeviceTimeStamp get _value => super._value as _$_DeviceTimeStamp;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_DeviceTimeStamp(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$_DeviceTimeStamp extends _DeviceTimeStamp {
  const _$_DeviceTimeStamp(this.value) : super._();

  @override
  final DateTime value;

  @override
  String toString() {
    return 'DeviceTimeStamp(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DeviceTimeStamp &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_DeviceTimeStampCopyWith<_$_DeviceTimeStamp> get copyWith =>
      __$$_DeviceTimeStampCopyWithImpl<_$_DeviceTimeStamp>(this, _$identity);
}

abstract class _DeviceTimeStamp extends DeviceTimeStamp {
  const factory _DeviceTimeStamp(final DateTime value) = _$_DeviceTimeStamp;
  const _DeviceTimeStamp._() : super._();

  @override
  DateTime get value;
  @override
  @JsonKey(ignore: true)
  _$$_DeviceTimeStampCopyWith<_$_DeviceTimeStamp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DialogType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() breakInterview,
    required TResult Function() reAnswer,
    required TResult Function() confirmFinished,
    required TResult Function() switchToSamplingWithinHouseholdModule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DialogTypeNone value) none,
    required TResult Function(DialogTypeBreakInterview value) breakInterview,
    required TResult Function(DialogTypeReAnswer value) reAnswer,
    required TResult Function(DialogTypeConfirmFinished value) confirmFinished,
    required TResult Function(
            DialogTypeSwitchToSamplingWithinHouseholdModule value)
        switchToSamplingWithinHouseholdModule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DialogTypeCopyWith<$Res> {
  factory $DialogTypeCopyWith(
          DialogType value, $Res Function(DialogType) then) =
      _$DialogTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$DialogTypeCopyWithImpl<$Res> implements $DialogTypeCopyWith<$Res> {
  _$DialogTypeCopyWithImpl(this._value, this._then);

  final DialogType _value;
  // ignore: unused_field
  final $Res Function(DialogType) _then;
}

/// @nodoc
abstract class _$$DialogTypeNoneCopyWith<$Res> {
  factory _$$DialogTypeNoneCopyWith(
          _$DialogTypeNone value, $Res Function(_$DialogTypeNone) then) =
      __$$DialogTypeNoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DialogTypeNoneCopyWithImpl<$Res>
    extends _$DialogTypeCopyWithImpl<$Res>
    implements _$$DialogTypeNoneCopyWith<$Res> {
  __$$DialogTypeNoneCopyWithImpl(
      _$DialogTypeNone _value, $Res Function(_$DialogTypeNone) _then)
      : super(_value, (v) => _then(v as _$DialogTypeNone));

  @override
  _$DialogTypeNone get _value => super._value as _$DialogTypeNone;
}

/// @nodoc

class _$DialogTypeNone extends DialogTypeNone {
  const _$DialogTypeNone() : super._();

  @override
  String toString() {
    return 'DialogType.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DialogTypeNone);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() breakInterview,
    required TResult Function() reAnswer,
    required TResult Function() confirmFinished,
    required TResult Function() switchToSamplingWithinHouseholdModule,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DialogTypeNone value) none,
    required TResult Function(DialogTypeBreakInterview value) breakInterview,
    required TResult Function(DialogTypeReAnswer value) reAnswer,
    required TResult Function(DialogTypeConfirmFinished value) confirmFinished,
    required TResult Function(
            DialogTypeSwitchToSamplingWithinHouseholdModule value)
        switchToSamplingWithinHouseholdModule,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class DialogTypeNone extends DialogType {
  const factory DialogTypeNone() = _$DialogTypeNone;
  const DialogTypeNone._() : super._();
}

/// @nodoc
abstract class _$$DialogTypeBreakInterviewCopyWith<$Res> {
  factory _$$DialogTypeBreakInterviewCopyWith(_$DialogTypeBreakInterview value,
          $Res Function(_$DialogTypeBreakInterview) then) =
      __$$DialogTypeBreakInterviewCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DialogTypeBreakInterviewCopyWithImpl<$Res>
    extends _$DialogTypeCopyWithImpl<$Res>
    implements _$$DialogTypeBreakInterviewCopyWith<$Res> {
  __$$DialogTypeBreakInterviewCopyWithImpl(_$DialogTypeBreakInterview _value,
      $Res Function(_$DialogTypeBreakInterview) _then)
      : super(_value, (v) => _then(v as _$DialogTypeBreakInterview));

  @override
  _$DialogTypeBreakInterview get _value =>
      super._value as _$DialogTypeBreakInterview;
}

/// @nodoc

class _$DialogTypeBreakInterview extends DialogTypeBreakInterview {
  const _$DialogTypeBreakInterview() : super._();

  @override
  String toString() {
    return 'DialogType.breakInterview()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DialogTypeBreakInterview);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() breakInterview,
    required TResult Function() reAnswer,
    required TResult Function() confirmFinished,
    required TResult Function() switchToSamplingWithinHouseholdModule,
  }) {
    return breakInterview();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
  }) {
    return breakInterview?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (breakInterview != null) {
      return breakInterview();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DialogTypeNone value) none,
    required TResult Function(DialogTypeBreakInterview value) breakInterview,
    required TResult Function(DialogTypeReAnswer value) reAnswer,
    required TResult Function(DialogTypeConfirmFinished value) confirmFinished,
    required TResult Function(
            DialogTypeSwitchToSamplingWithinHouseholdModule value)
        switchToSamplingWithinHouseholdModule,
  }) {
    return breakInterview(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
  }) {
    return breakInterview?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (breakInterview != null) {
      return breakInterview(this);
    }
    return orElse();
  }
}

abstract class DialogTypeBreakInterview extends DialogType {
  const factory DialogTypeBreakInterview() = _$DialogTypeBreakInterview;
  const DialogTypeBreakInterview._() : super._();
}

/// @nodoc
abstract class _$$DialogTypeReAnswerCopyWith<$Res> {
  factory _$$DialogTypeReAnswerCopyWith(_$DialogTypeReAnswer value,
          $Res Function(_$DialogTypeReAnswer) then) =
      __$$DialogTypeReAnswerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DialogTypeReAnswerCopyWithImpl<$Res>
    extends _$DialogTypeCopyWithImpl<$Res>
    implements _$$DialogTypeReAnswerCopyWith<$Res> {
  __$$DialogTypeReAnswerCopyWithImpl(
      _$DialogTypeReAnswer _value, $Res Function(_$DialogTypeReAnswer) _then)
      : super(_value, (v) => _then(v as _$DialogTypeReAnswer));

  @override
  _$DialogTypeReAnswer get _value => super._value as _$DialogTypeReAnswer;
}

/// @nodoc

class _$DialogTypeReAnswer extends DialogTypeReAnswer {
  const _$DialogTypeReAnswer() : super._();

  @override
  String toString() {
    return 'DialogType.reAnswer()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DialogTypeReAnswer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() breakInterview,
    required TResult Function() reAnswer,
    required TResult Function() confirmFinished,
    required TResult Function() switchToSamplingWithinHouseholdModule,
  }) {
    return reAnswer();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
  }) {
    return reAnswer?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (reAnswer != null) {
      return reAnswer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DialogTypeNone value) none,
    required TResult Function(DialogTypeBreakInterview value) breakInterview,
    required TResult Function(DialogTypeReAnswer value) reAnswer,
    required TResult Function(DialogTypeConfirmFinished value) confirmFinished,
    required TResult Function(
            DialogTypeSwitchToSamplingWithinHouseholdModule value)
        switchToSamplingWithinHouseholdModule,
  }) {
    return reAnswer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
  }) {
    return reAnswer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (reAnswer != null) {
      return reAnswer(this);
    }
    return orElse();
  }
}

abstract class DialogTypeReAnswer extends DialogType {
  const factory DialogTypeReAnswer() = _$DialogTypeReAnswer;
  const DialogTypeReAnswer._() : super._();
}

/// @nodoc
abstract class _$$DialogTypeConfirmFinishedCopyWith<$Res> {
  factory _$$DialogTypeConfirmFinishedCopyWith(
          _$DialogTypeConfirmFinished value,
          $Res Function(_$DialogTypeConfirmFinished) then) =
      __$$DialogTypeConfirmFinishedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DialogTypeConfirmFinishedCopyWithImpl<$Res>
    extends _$DialogTypeCopyWithImpl<$Res>
    implements _$$DialogTypeConfirmFinishedCopyWith<$Res> {
  __$$DialogTypeConfirmFinishedCopyWithImpl(_$DialogTypeConfirmFinished _value,
      $Res Function(_$DialogTypeConfirmFinished) _then)
      : super(_value, (v) => _then(v as _$DialogTypeConfirmFinished));

  @override
  _$DialogTypeConfirmFinished get _value =>
      super._value as _$DialogTypeConfirmFinished;
}

/// @nodoc

class _$DialogTypeConfirmFinished extends DialogTypeConfirmFinished {
  const _$DialogTypeConfirmFinished() : super._();

  @override
  String toString() {
    return 'DialogType.confirmFinished()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DialogTypeConfirmFinished);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() breakInterview,
    required TResult Function() reAnswer,
    required TResult Function() confirmFinished,
    required TResult Function() switchToSamplingWithinHouseholdModule,
  }) {
    return confirmFinished();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
  }) {
    return confirmFinished?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (confirmFinished != null) {
      return confirmFinished();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DialogTypeNone value) none,
    required TResult Function(DialogTypeBreakInterview value) breakInterview,
    required TResult Function(DialogTypeReAnswer value) reAnswer,
    required TResult Function(DialogTypeConfirmFinished value) confirmFinished,
    required TResult Function(
            DialogTypeSwitchToSamplingWithinHouseholdModule value)
        switchToSamplingWithinHouseholdModule,
  }) {
    return confirmFinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
  }) {
    return confirmFinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (confirmFinished != null) {
      return confirmFinished(this);
    }
    return orElse();
  }
}

abstract class DialogTypeConfirmFinished extends DialogType {
  const factory DialogTypeConfirmFinished() = _$DialogTypeConfirmFinished;
  const DialogTypeConfirmFinished._() : super._();
}

/// @nodoc
abstract class _$$DialogTypeSwitchToSamplingWithinHouseholdModuleCopyWith<
    $Res> {
  factory _$$DialogTypeSwitchToSamplingWithinHouseholdModuleCopyWith(
          _$DialogTypeSwitchToSamplingWithinHouseholdModule value,
          $Res Function(_$DialogTypeSwitchToSamplingWithinHouseholdModule)
              then) =
      __$$DialogTypeSwitchToSamplingWithinHouseholdModuleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DialogTypeSwitchToSamplingWithinHouseholdModuleCopyWithImpl<$Res>
    extends _$DialogTypeCopyWithImpl<$Res>
    implements
        _$$DialogTypeSwitchToSamplingWithinHouseholdModuleCopyWith<$Res> {
  __$$DialogTypeSwitchToSamplingWithinHouseholdModuleCopyWithImpl(
      _$DialogTypeSwitchToSamplingWithinHouseholdModule _value,
      $Res Function(_$DialogTypeSwitchToSamplingWithinHouseholdModule) _then)
      : super(
            _value,
            (v) =>
                _then(v as _$DialogTypeSwitchToSamplingWithinHouseholdModule));

  @override
  _$DialogTypeSwitchToSamplingWithinHouseholdModule get _value =>
      super._value as _$DialogTypeSwitchToSamplingWithinHouseholdModule;
}

/// @nodoc

class _$DialogTypeSwitchToSamplingWithinHouseholdModule
    extends DialogTypeSwitchToSamplingWithinHouseholdModule {
  const _$DialogTypeSwitchToSamplingWithinHouseholdModule() : super._();

  @override
  String toString() {
    return 'DialogType.switchToSamplingWithinHouseholdModule()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DialogTypeSwitchToSamplingWithinHouseholdModule);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() breakInterview,
    required TResult Function() reAnswer,
    required TResult Function() confirmFinished,
    required TResult Function() switchToSamplingWithinHouseholdModule,
  }) {
    return switchToSamplingWithinHouseholdModule();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
  }) {
    return switchToSamplingWithinHouseholdModule?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? breakInterview,
    TResult Function()? reAnswer,
    TResult Function()? confirmFinished,
    TResult Function()? switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (switchToSamplingWithinHouseholdModule != null) {
      return switchToSamplingWithinHouseholdModule();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DialogTypeNone value) none,
    required TResult Function(DialogTypeBreakInterview value) breakInterview,
    required TResult Function(DialogTypeReAnswer value) reAnswer,
    required TResult Function(DialogTypeConfirmFinished value) confirmFinished,
    required TResult Function(
            DialogTypeSwitchToSamplingWithinHouseholdModule value)
        switchToSamplingWithinHouseholdModule,
  }) {
    return switchToSamplingWithinHouseholdModule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
  }) {
    return switchToSamplingWithinHouseholdModule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DialogTypeNone value)? none,
    TResult Function(DialogTypeBreakInterview value)? breakInterview,
    TResult Function(DialogTypeReAnswer value)? reAnswer,
    TResult Function(DialogTypeConfirmFinished value)? confirmFinished,
    TResult Function(DialogTypeSwitchToSamplingWithinHouseholdModule value)?
        switchToSamplingWithinHouseholdModule,
    required TResult orElse(),
  }) {
    if (switchToSamplingWithinHouseholdModule != null) {
      return switchToSamplingWithinHouseholdModule(this);
    }
    return orElse();
  }
}

abstract class DialogTypeSwitchToSamplingWithinHouseholdModule
    extends DialogType {
  const factory DialogTypeSwitchToSamplingWithinHouseholdModule() =
      _$DialogTypeSwitchToSamplingWithinHouseholdModule;
  const DialogTypeSwitchToSamplingWithinHouseholdModule._() : super._();
}
