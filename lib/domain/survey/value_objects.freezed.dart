// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'value_objects.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FormatTypeTearOff {
  const _$FormatTypeTearOff();

  _FormatType call(String value) {
    return _FormatType(
      value,
    );
  }
}

/// @nodoc
const $FormatType = _$FormatTypeTearOff();

/// @nodoc
mixin _$FormatType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FormatTypeCopyWith<FormatType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormatTypeCopyWith<$Res> {
  factory $FormatTypeCopyWith(
          FormatType value, $Res Function(FormatType) then) =
      _$FormatTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$FormatTypeCopyWithImpl<$Res> implements $FormatTypeCopyWith<$Res> {
  _$FormatTypeCopyWithImpl(this._value, this._then);

  final FormatType _value;
  // ignore: unused_field
  final $Res Function(FormatType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$FormatTypeCopyWith<$Res> implements $FormatTypeCopyWith<$Res> {
  factory _$FormatTypeCopyWith(
          _FormatType value, $Res Function(_FormatType) then) =
      __$FormatTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$FormatTypeCopyWithImpl<$Res> extends _$FormatTypeCopyWithImpl<$Res>
    implements _$FormatTypeCopyWith<$Res> {
  __$FormatTypeCopyWithImpl(
      _FormatType _value, $Res Function(_FormatType) _then)
      : super(_value, (v) => _then(v as _FormatType));

  @override
  _FormatType get _value => super._value as _FormatType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_FormatType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_FormatType extends _FormatType {
  const _$_FormatType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'FormatType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FormatType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$FormatTypeCopyWith<_FormatType> get copyWith =>
      __$FormatTypeCopyWithImpl<_FormatType>(this, _$identity);
}

abstract class _FormatType extends FormatType {
  const factory _FormatType(String value) = _$_FormatType;
  const _FormatType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$FormatTypeCopyWith<_FormatType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$QuestionTypeTearOff {
  const _$QuestionTypeTearOff();

  _QuestionType call(String value) {
    return _QuestionType(
      value,
    );
  }
}

/// @nodoc
const $QuestionType = _$QuestionTypeTearOff();

/// @nodoc
mixin _$QuestionType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $QuestionTypeCopyWith<QuestionType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionTypeCopyWith<$Res> {
  factory $QuestionTypeCopyWith(
          QuestionType value, $Res Function(QuestionType) then) =
      _$QuestionTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$QuestionTypeCopyWithImpl<$Res> implements $QuestionTypeCopyWith<$Res> {
  _$QuestionTypeCopyWithImpl(this._value, this._then);

  final QuestionType _value;
  // ignore: unused_field
  final $Res Function(QuestionType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$QuestionTypeCopyWith<$Res>
    implements $QuestionTypeCopyWith<$Res> {
  factory _$QuestionTypeCopyWith(
          _QuestionType value, $Res Function(_QuestionType) then) =
      __$QuestionTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$QuestionTypeCopyWithImpl<$Res> extends _$QuestionTypeCopyWithImpl<$Res>
    implements _$QuestionTypeCopyWith<$Res> {
  __$QuestionTypeCopyWithImpl(
      _QuestionType _value, $Res Function(_QuestionType) _then)
      : super(_value, (v) => _then(v as _QuestionType));

  @override
  _QuestionType get _value => super._value as _QuestionType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_QuestionType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_QuestionType extends _QuestionType {
  const _$_QuestionType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'QuestionType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _QuestionType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$QuestionTypeCopyWith<_QuestionType> get copyWith =>
      __$QuestionTypeCopyWithImpl<_QuestionType>(this, _$identity);
}

abstract class _QuestionType extends QuestionType {
  const factory _QuestionType(String value) = _$_QuestionType;
  const _QuestionType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$QuestionTypeCopyWith<_QuestionType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AnswerTypeTearOff {
  const _$AnswerTypeTearOff();

  _AnswerType call(String value) {
    return _AnswerType(
      value,
    );
  }
}

/// @nodoc
const $AnswerType = _$AnswerTypeTearOff();

/// @nodoc
mixin _$AnswerType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerTypeCopyWith<AnswerType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerTypeCopyWith<$Res> {
  factory $AnswerTypeCopyWith(
          AnswerType value, $Res Function(AnswerType) then) =
      _$AnswerTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$AnswerTypeCopyWithImpl<$Res> implements $AnswerTypeCopyWith<$Res> {
  _$AnswerTypeCopyWithImpl(this._value, this._then);

  final AnswerType _value;
  // ignore: unused_field
  final $Res Function(AnswerType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$AnswerTypeCopyWith<$Res> implements $AnswerTypeCopyWith<$Res> {
  factory _$AnswerTypeCopyWith(
          _AnswerType value, $Res Function(_AnswerType) then) =
      __$AnswerTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$AnswerTypeCopyWithImpl<$Res> extends _$AnswerTypeCopyWithImpl<$Res>
    implements _$AnswerTypeCopyWith<$Res> {
  __$AnswerTypeCopyWithImpl(
      _AnswerType _value, $Res Function(_AnswerType) _then)
      : super(_value, (v) => _then(v as _AnswerType));

  @override
  _AnswerType get _value => super._value as _AnswerType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_AnswerType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_AnswerType extends _AnswerType {
  const _$_AnswerType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'AnswerType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AnswerType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$AnswerTypeCopyWith<_AnswerType> get copyWith =>
      __$AnswerTypeCopyWithImpl<_AnswerType>(this, _$identity);
}

abstract class _AnswerType extends AnswerType {
  const factory _AnswerType(String value) = _$_AnswerType;
  const _AnswerType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$AnswerTypeCopyWith<_AnswerType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AnswerStatusTypeTearOff {
  const _$AnswerStatusTypeTearOff();

  _AnswerStatusType call(String value) {
    return _AnswerStatusType(
      value,
    );
  }
}

/// @nodoc
const $AnswerStatusType = _$AnswerStatusTypeTearOff();

/// @nodoc
mixin _$AnswerStatusType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerStatusTypeCopyWith<AnswerStatusType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerStatusTypeCopyWith<$Res> {
  factory $AnswerStatusTypeCopyWith(
          AnswerStatusType value, $Res Function(AnswerStatusType) then) =
      _$AnswerStatusTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$AnswerStatusTypeCopyWithImpl<$Res>
    implements $AnswerStatusTypeCopyWith<$Res> {
  _$AnswerStatusTypeCopyWithImpl(this._value, this._then);

  final AnswerStatusType _value;
  // ignore: unused_field
  final $Res Function(AnswerStatusType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$AnswerStatusTypeCopyWith<$Res>
    implements $AnswerStatusTypeCopyWith<$Res> {
  factory _$AnswerStatusTypeCopyWith(
          _AnswerStatusType value, $Res Function(_AnswerStatusType) then) =
      __$AnswerStatusTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$AnswerStatusTypeCopyWithImpl<$Res>
    extends _$AnswerStatusTypeCopyWithImpl<$Res>
    implements _$AnswerStatusTypeCopyWith<$Res> {
  __$AnswerStatusTypeCopyWithImpl(
      _AnswerStatusType _value, $Res Function(_AnswerStatusType) _then)
      : super(_value, (v) => _then(v as _AnswerStatusType));

  @override
  _AnswerStatusType get _value => super._value as _AnswerStatusType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_AnswerStatusType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_AnswerStatusType extends _AnswerStatusType {
  const _$_AnswerStatusType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'AnswerStatusType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AnswerStatusType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$AnswerStatusTypeCopyWith<_AnswerStatusType> get copyWith =>
      __$AnswerStatusTypeCopyWithImpl<_AnswerStatusType>(this, _$identity);
}

abstract class _AnswerStatusType extends AnswerStatusType {
  const factory _AnswerStatusType(String value) = _$_AnswerStatusType;
  const _AnswerStatusType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$AnswerStatusTypeCopyWith<_AnswerStatusType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$WarningTypeTearOff {
  const _$WarningTypeTearOff();

  _WarningType call(String value) {
    return _WarningType(
      value,
    );
  }
}

/// @nodoc
const $WarningType = _$WarningTypeTearOff();

/// @nodoc
mixin _$WarningType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WarningTypeCopyWith<WarningType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarningTypeCopyWith<$Res> {
  factory $WarningTypeCopyWith(
          WarningType value, $Res Function(WarningType) then) =
      _$WarningTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$WarningTypeCopyWithImpl<$Res> implements $WarningTypeCopyWith<$Res> {
  _$WarningTypeCopyWithImpl(this._value, this._then);

  final WarningType _value;
  // ignore: unused_field
  final $Res Function(WarningType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$WarningTypeCopyWith<$Res>
    implements $WarningTypeCopyWith<$Res> {
  factory _$WarningTypeCopyWith(
          _WarningType value, $Res Function(_WarningType) then) =
      __$WarningTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$WarningTypeCopyWithImpl<$Res> extends _$WarningTypeCopyWithImpl<$Res>
    implements _$WarningTypeCopyWith<$Res> {
  __$WarningTypeCopyWithImpl(
      _WarningType _value, $Res Function(_WarningType) _then)
      : super(_value, (v) => _then(v as _WarningType));

  @override
  _WarningType get _value => super._value as _WarningType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_WarningType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_WarningType extends _WarningType {
  const _$_WarningType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'WarningType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _WarningType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$WarningTypeCopyWith<_WarningType> get copyWith =>
      __$WarningTypeCopyWithImpl<_WarningType>(this, _$identity);
}

abstract class _WarningType extends WarningType {
  const factory _WarningType(String value) = _$_WarningType;
  const _WarningType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$WarningTypeCopyWith<_WarningType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$OperatorTearOff {
  const _$OperatorTearOff();

  _Operator call(String value) {
    return _Operator(
      value,
    );
  }
}

/// @nodoc
const $Operator = _$OperatorTearOff();

/// @nodoc
mixin _$Operator {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OperatorCopyWith<Operator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperatorCopyWith<$Res> {
  factory $OperatorCopyWith(Operator value, $Res Function(Operator) then) =
      _$OperatorCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$OperatorCopyWithImpl<$Res> implements $OperatorCopyWith<$Res> {
  _$OperatorCopyWithImpl(this._value, this._then);

  final Operator _value;
  // ignore: unused_field
  final $Res Function(Operator) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$OperatorCopyWith<$Res> implements $OperatorCopyWith<$Res> {
  factory _$OperatorCopyWith(_Operator value, $Res Function(_Operator) then) =
      __$OperatorCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$OperatorCopyWithImpl<$Res> extends _$OperatorCopyWithImpl<$Res>
    implements _$OperatorCopyWith<$Res> {
  __$OperatorCopyWithImpl(_Operator _value, $Res Function(_Operator) _then)
      : super(_value, (v) => _then(v as _Operator));

  @override
  _Operator get _value => super._value as _Operator;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_Operator(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Operator extends _Operator {
  const _$_Operator(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'Operator(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Operator &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$OperatorCopyWith<_Operator> get copyWith =>
      __$OperatorCopyWithImpl<_Operator>(this, _$identity);
}

abstract class _Operator extends Operator {
  const factory _Operator(String value) = _$_Operator;
  const _Operator._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$OperatorCopyWith<_Operator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModuleTypeTearOff {
  const _$ModuleTypeTearOff();

  _ModuleType call(String value) {
    return _ModuleType(
      value,
    );
  }
}

/// @nodoc
const $ModuleType = _$ModuleTypeTearOff();

/// @nodoc
mixin _$ModuleType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModuleTypeCopyWith<ModuleType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModuleTypeCopyWith<$Res> {
  factory $ModuleTypeCopyWith(
          ModuleType value, $Res Function(ModuleType) then) =
      _$ModuleTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$ModuleTypeCopyWithImpl<$Res> implements $ModuleTypeCopyWith<$Res> {
  _$ModuleTypeCopyWithImpl(this._value, this._then);

  final ModuleType _value;
  // ignore: unused_field
  final $Res Function(ModuleType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$ModuleTypeCopyWith<$Res> implements $ModuleTypeCopyWith<$Res> {
  factory _$ModuleTypeCopyWith(
          _ModuleType value, $Res Function(_ModuleType) then) =
      __$ModuleTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$ModuleTypeCopyWithImpl<$Res> extends _$ModuleTypeCopyWithImpl<$Res>
    implements _$ModuleTypeCopyWith<$Res> {
  __$ModuleTypeCopyWithImpl(
      _ModuleType _value, $Res Function(_ModuleType) _then)
      : super(_value, (v) => _then(v as _ModuleType));

  @override
  _ModuleType get _value => super._value as _ModuleType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_ModuleType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ModuleType extends _ModuleType {
  const _$_ModuleType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'ModuleType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModuleType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$ModuleTypeCopyWith<_ModuleType> get copyWith =>
      __$ModuleTypeCopyWithImpl<_ModuleType>(this, _$identity);
}

abstract class _ModuleType extends ModuleType {
  const factory _ModuleType(String value) = _$_ModuleType;
  const _ModuleType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$ModuleTypeCopyWith<_ModuleType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ResponseStatusTearOff {
  const _$ResponseStatusTearOff();

  _ResponseStatus call(String value) {
    return _ResponseStatus(
      value,
    );
  }
}

/// @nodoc
const $ResponseStatus = _$ResponseStatusTearOff();

/// @nodoc
mixin _$ResponseStatus {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ResponseStatusCopyWith<ResponseStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseStatusCopyWith<$Res> {
  factory $ResponseStatusCopyWith(
          ResponseStatus value, $Res Function(ResponseStatus) then) =
      _$ResponseStatusCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$ResponseStatusCopyWithImpl<$Res>
    implements $ResponseStatusCopyWith<$Res> {
  _$ResponseStatusCopyWithImpl(this._value, this._then);

  final ResponseStatus _value;
  // ignore: unused_field
  final $Res Function(ResponseStatus) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$ResponseStatusCopyWith<$Res>
    implements $ResponseStatusCopyWith<$Res> {
  factory _$ResponseStatusCopyWith(
          _ResponseStatus value, $Res Function(_ResponseStatus) then) =
      __$ResponseStatusCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$ResponseStatusCopyWithImpl<$Res>
    extends _$ResponseStatusCopyWithImpl<$Res>
    implements _$ResponseStatusCopyWith<$Res> {
  __$ResponseStatusCopyWithImpl(
      _ResponseStatus _value, $Res Function(_ResponseStatus) _then)
      : super(_value, (v) => _then(v as _ResponseStatus));

  @override
  _ResponseStatus get _value => super._value as _ResponseStatus;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_ResponseStatus(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ResponseStatus extends _ResponseStatus {
  const _$_ResponseStatus(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'ResponseStatus(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ResponseStatus &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$ResponseStatusCopyWith<_ResponseStatus> get copyWith =>
      __$ResponseStatusCopyWithImpl<_ResponseStatus>(this, _$identity);
}

abstract class _ResponseStatus extends ResponseStatus {
  const factory _ResponseStatus(String value) = _$_ResponseStatus;
  const _ResponseStatus._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$ResponseStatusCopyWith<_ResponseStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$DeviceTimeStampTearOff {
  const _$DeviceTimeStampTearOff();

  _DeviceTimeStamp call(DateTime value) {
    return _DeviceTimeStamp(
      value,
    );
  }
}

/// @nodoc
const $DeviceTimeStamp = _$DeviceTimeStampTearOff();

/// @nodoc
mixin _$DeviceTimeStamp {
  DateTime get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeviceTimeStampCopyWith<DeviceTimeStamp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceTimeStampCopyWith<$Res> {
  factory $DeviceTimeStampCopyWith(
          DeviceTimeStamp value, $Res Function(DeviceTimeStamp) then) =
      _$DeviceTimeStampCopyWithImpl<$Res>;
  $Res call({DateTime value});
}

/// @nodoc
class _$DeviceTimeStampCopyWithImpl<$Res>
    implements $DeviceTimeStampCopyWith<$Res> {
  _$DeviceTimeStampCopyWithImpl(this._value, this._then);

  final DeviceTimeStamp _value;
  // ignore: unused_field
  final $Res Function(DeviceTimeStamp) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$DeviceTimeStampCopyWith<$Res>
    implements $DeviceTimeStampCopyWith<$Res> {
  factory _$DeviceTimeStampCopyWith(
          _DeviceTimeStamp value, $Res Function(_DeviceTimeStamp) then) =
      __$DeviceTimeStampCopyWithImpl<$Res>;
  @override
  $Res call({DateTime value});
}

/// @nodoc
class __$DeviceTimeStampCopyWithImpl<$Res>
    extends _$DeviceTimeStampCopyWithImpl<$Res>
    implements _$DeviceTimeStampCopyWith<$Res> {
  __$DeviceTimeStampCopyWithImpl(
      _DeviceTimeStamp _value, $Res Function(_DeviceTimeStamp) _then)
      : super(_value, (v) => _then(v as _DeviceTimeStamp));

  @override
  _DeviceTimeStamp get _value => super._value as _DeviceTimeStamp;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_DeviceTimeStamp(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$_DeviceTimeStamp extends _DeviceTimeStamp {
  const _$_DeviceTimeStamp(this.value) : super._();

  @override
  final DateTime value;

  @override
  String toString() {
    return 'DeviceTimeStamp(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeviceTimeStamp &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$DeviceTimeStampCopyWith<_DeviceTimeStamp> get copyWith =>
      __$DeviceTimeStampCopyWithImpl<_DeviceTimeStamp>(this, _$identity);
}

abstract class _DeviceTimeStamp extends DeviceTimeStamp {
  const factory _DeviceTimeStamp(DateTime value) = _$_DeviceTimeStamp;
  const _DeviceTimeStamp._() : super._();

  @override
  DateTime get value;
  @override
  @JsonKey(ignore: true)
  _$DeviceTimeStampCopyWith<_DeviceTimeStamp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$DialogTypeTearOff {
  const _$DialogTypeTearOff();

  _DialogType call(String value) {
    return _DialogType(
      value,
    );
  }
}

/// @nodoc
const $DialogType = _$DialogTypeTearOff();

/// @nodoc
mixin _$DialogType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DialogTypeCopyWith<DialogType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DialogTypeCopyWith<$Res> {
  factory $DialogTypeCopyWith(
          DialogType value, $Res Function(DialogType) then) =
      _$DialogTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$DialogTypeCopyWithImpl<$Res> implements $DialogTypeCopyWith<$Res> {
  _$DialogTypeCopyWithImpl(this._value, this._then);

  final DialogType _value;
  // ignore: unused_field
  final $Res Function(DialogType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$DialogTypeCopyWith<$Res> implements $DialogTypeCopyWith<$Res> {
  factory _$DialogTypeCopyWith(
          _DialogType value, $Res Function(_DialogType) then) =
      __$DialogTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$DialogTypeCopyWithImpl<$Res> extends _$DialogTypeCopyWithImpl<$Res>
    implements _$DialogTypeCopyWith<$Res> {
  __$DialogTypeCopyWithImpl(
      _DialogType _value, $Res Function(_DialogType) _then)
      : super(_value, (v) => _then(v as _DialogType));

  @override
  _DialogType get _value => super._value as _DialogType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_DialogType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_DialogType extends _DialogType {
  const _$_DialogType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'DialogType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DialogType &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  _$DialogTypeCopyWith<_DialogType> get copyWith =>
      __$DialogTypeCopyWithImpl<_DialogType>(this, _$identity);
}

abstract class _DialogType extends DialogType {
  const factory _DialogType(String value) = _$_DialogType;
  const _DialogType._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$DialogTypeCopyWith<_DialogType> get copyWith =>
      throw _privateConstructorUsedError;
}
