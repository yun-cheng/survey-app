// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'value_objects.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FormatType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FormatTypeCopyWith<FormatType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormatTypeCopyWith<$Res> {
  factory $FormatTypeCopyWith(
          FormatType value, $Res Function(FormatType) then) =
      _$FormatTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$FormatTypeCopyWithImpl<$Res> implements $FormatTypeCopyWith<$Res> {
  _$FormatTypeCopyWithImpl(this._value, this._then);

  final FormatType _value;
  // ignore: unused_field
  final $Res Function(FormatType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_FormatTypeCopyWith<$Res>
    implements $FormatTypeCopyWith<$Res> {
  factory _$$_FormatTypeCopyWith(
          _$_FormatType value, $Res Function(_$_FormatType) then) =
      __$$_FormatTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_FormatTypeCopyWithImpl<$Res> extends _$FormatTypeCopyWithImpl<$Res>
    implements _$$_FormatTypeCopyWith<$Res> {
  __$$_FormatTypeCopyWithImpl(
      _$_FormatType _value, $Res Function(_$_FormatType) _then)
      : super(_value, (v) => _then(v as _$_FormatType));

  @override
  _$_FormatType get _value => super._value as _$_FormatType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_FormatType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_FormatType extends _FormatType {
  const _$_FormatType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'FormatType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FormatType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_FormatTypeCopyWith<_$_FormatType> get copyWith =>
      __$$_FormatTypeCopyWithImpl<_$_FormatType>(this, _$identity);
}

abstract class _FormatType extends FormatType {
  const factory _FormatType(final String value) = _$_FormatType;
  const _FormatType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_FormatTypeCopyWith<_$_FormatType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$QuestionType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $QuestionTypeCopyWith<QuestionType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionTypeCopyWith<$Res> {
  factory $QuestionTypeCopyWith(
          QuestionType value, $Res Function(QuestionType) then) =
      _$QuestionTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$QuestionTypeCopyWithImpl<$Res> implements $QuestionTypeCopyWith<$Res> {
  _$QuestionTypeCopyWithImpl(this._value, this._then);

  final QuestionType _value;
  // ignore: unused_field
  final $Res Function(QuestionType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_QuestionTypeCopyWith<$Res>
    implements $QuestionTypeCopyWith<$Res> {
  factory _$$_QuestionTypeCopyWith(
          _$_QuestionType value, $Res Function(_$_QuestionType) then) =
      __$$_QuestionTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_QuestionTypeCopyWithImpl<$Res>
    extends _$QuestionTypeCopyWithImpl<$Res>
    implements _$$_QuestionTypeCopyWith<$Res> {
  __$$_QuestionTypeCopyWithImpl(
      _$_QuestionType _value, $Res Function(_$_QuestionType) _then)
      : super(_value, (v) => _then(v as _$_QuestionType));

  @override
  _$_QuestionType get _value => super._value as _$_QuestionType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_QuestionType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_QuestionType extends _QuestionType {
  const _$_QuestionType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'QuestionType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QuestionType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_QuestionTypeCopyWith<_$_QuestionType> get copyWith =>
      __$$_QuestionTypeCopyWithImpl<_$_QuestionType>(this, _$identity);
}

abstract class _QuestionType extends QuestionType {
  const factory _QuestionType(final String value) = _$_QuestionType;
  const _QuestionType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_QuestionTypeCopyWith<_$_QuestionType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnswerType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerTypeCopyWith<AnswerType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerTypeCopyWith<$Res> {
  factory $AnswerTypeCopyWith(
          AnswerType value, $Res Function(AnswerType) then) =
      _$AnswerTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$AnswerTypeCopyWithImpl<$Res> implements $AnswerTypeCopyWith<$Res> {
  _$AnswerTypeCopyWithImpl(this._value, this._then);

  final AnswerType _value;
  // ignore: unused_field
  final $Res Function(AnswerType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_AnswerTypeCopyWith<$Res>
    implements $AnswerTypeCopyWith<$Res> {
  factory _$$_AnswerTypeCopyWith(
          _$_AnswerType value, $Res Function(_$_AnswerType) then) =
      __$$_AnswerTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_AnswerTypeCopyWithImpl<$Res> extends _$AnswerTypeCopyWithImpl<$Res>
    implements _$$_AnswerTypeCopyWith<$Res> {
  __$$_AnswerTypeCopyWithImpl(
      _$_AnswerType _value, $Res Function(_$_AnswerType) _then)
      : super(_value, (v) => _then(v as _$_AnswerType));

  @override
  _$_AnswerType get _value => super._value as _$_AnswerType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_AnswerType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_AnswerType extends _AnswerType {
  const _$_AnswerType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'AnswerType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnswerType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_AnswerTypeCopyWith<_$_AnswerType> get copyWith =>
      __$$_AnswerTypeCopyWithImpl<_$_AnswerType>(this, _$identity);
}

abstract class _AnswerType extends AnswerType {
  const factory _AnswerType(final String value) = _$_AnswerType;
  const _AnswerType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AnswerTypeCopyWith<_$_AnswerType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnswerStatusType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerStatusTypeCopyWith<AnswerStatusType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerStatusTypeCopyWith<$Res> {
  factory $AnswerStatusTypeCopyWith(
          AnswerStatusType value, $Res Function(AnswerStatusType) then) =
      _$AnswerStatusTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$AnswerStatusTypeCopyWithImpl<$Res>
    implements $AnswerStatusTypeCopyWith<$Res> {
  _$AnswerStatusTypeCopyWithImpl(this._value, this._then);

  final AnswerStatusType _value;
  // ignore: unused_field
  final $Res Function(AnswerStatusType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_AnswerStatusTypeCopyWith<$Res>
    implements $AnswerStatusTypeCopyWith<$Res> {
  factory _$$_AnswerStatusTypeCopyWith(
          _$_AnswerStatusType value, $Res Function(_$_AnswerStatusType) then) =
      __$$_AnswerStatusTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_AnswerStatusTypeCopyWithImpl<$Res>
    extends _$AnswerStatusTypeCopyWithImpl<$Res>
    implements _$$_AnswerStatusTypeCopyWith<$Res> {
  __$$_AnswerStatusTypeCopyWithImpl(
      _$_AnswerStatusType _value, $Res Function(_$_AnswerStatusType) _then)
      : super(_value, (v) => _then(v as _$_AnswerStatusType));

  @override
  _$_AnswerStatusType get _value => super._value as _$_AnswerStatusType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_AnswerStatusType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_AnswerStatusType extends _AnswerStatusType {
  const _$_AnswerStatusType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'AnswerStatusType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnswerStatusType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_AnswerStatusTypeCopyWith<_$_AnswerStatusType> get copyWith =>
      __$$_AnswerStatusTypeCopyWithImpl<_$_AnswerStatusType>(this, _$identity);
}

abstract class _AnswerStatusType extends AnswerStatusType {
  const factory _AnswerStatusType(final String value) = _$_AnswerStatusType;
  const _AnswerStatusType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AnswerStatusTypeCopyWith<_$_AnswerStatusType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WarningType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WarningTypeCopyWith<WarningType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarningTypeCopyWith<$Res> {
  factory $WarningTypeCopyWith(
          WarningType value, $Res Function(WarningType) then) =
      _$WarningTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$WarningTypeCopyWithImpl<$Res> implements $WarningTypeCopyWith<$Res> {
  _$WarningTypeCopyWithImpl(this._value, this._then);

  final WarningType _value;
  // ignore: unused_field
  final $Res Function(WarningType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_WarningTypeCopyWith<$Res>
    implements $WarningTypeCopyWith<$Res> {
  factory _$$_WarningTypeCopyWith(
          _$_WarningType value, $Res Function(_$_WarningType) then) =
      __$$_WarningTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_WarningTypeCopyWithImpl<$Res> extends _$WarningTypeCopyWithImpl<$Res>
    implements _$$_WarningTypeCopyWith<$Res> {
  __$$_WarningTypeCopyWithImpl(
      _$_WarningType _value, $Res Function(_$_WarningType) _then)
      : super(_value, (v) => _then(v as _$_WarningType));

  @override
  _$_WarningType get _value => super._value as _$_WarningType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_WarningType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_WarningType extends _WarningType {
  const _$_WarningType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'WarningType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WarningType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_WarningTypeCopyWith<_$_WarningType> get copyWith =>
      __$$_WarningTypeCopyWithImpl<_$_WarningType>(this, _$identity);
}

abstract class _WarningType extends WarningType {
  const factory _WarningType(final String value) = _$_WarningType;
  const _WarningType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_WarningTypeCopyWith<_$_WarningType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Operator {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OperatorCopyWith<Operator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperatorCopyWith<$Res> {
  factory $OperatorCopyWith(Operator value, $Res Function(Operator) then) =
      _$OperatorCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$OperatorCopyWithImpl<$Res> implements $OperatorCopyWith<$Res> {
  _$OperatorCopyWithImpl(this._value, this._then);

  final Operator _value;
  // ignore: unused_field
  final $Res Function(Operator) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_OperatorCopyWith<$Res> implements $OperatorCopyWith<$Res> {
  factory _$$_OperatorCopyWith(
          _$_Operator value, $Res Function(_$_Operator) then) =
      __$$_OperatorCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_OperatorCopyWithImpl<$Res> extends _$OperatorCopyWithImpl<$Res>
    implements _$$_OperatorCopyWith<$Res> {
  __$$_OperatorCopyWithImpl(
      _$_Operator _value, $Res Function(_$_Operator) _then)
      : super(_value, (v) => _then(v as _$_Operator));

  @override
  _$_Operator get _value => super._value as _$_Operator;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_Operator(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Operator extends _Operator {
  const _$_Operator(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'Operator(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Operator &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_OperatorCopyWith<_$_Operator> get copyWith =>
      __$$_OperatorCopyWithImpl<_$_Operator>(this, _$identity);
}

abstract class _Operator extends Operator {
  const factory _Operator(final String value) = _$_Operator;
  const _Operator._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_OperatorCopyWith<_$_Operator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ModuleType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModuleTypeCopyWith<ModuleType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModuleTypeCopyWith<$Res> {
  factory $ModuleTypeCopyWith(
          ModuleType value, $Res Function(ModuleType) then) =
      _$ModuleTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$ModuleTypeCopyWithImpl<$Res> implements $ModuleTypeCopyWith<$Res> {
  _$ModuleTypeCopyWithImpl(this._value, this._then);

  final ModuleType _value;
  // ignore: unused_field
  final $Res Function(ModuleType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_ModuleTypeCopyWith<$Res>
    implements $ModuleTypeCopyWith<$Res> {
  factory _$$_ModuleTypeCopyWith(
          _$_ModuleType value, $Res Function(_$_ModuleType) then) =
      __$$_ModuleTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_ModuleTypeCopyWithImpl<$Res> extends _$ModuleTypeCopyWithImpl<$Res>
    implements _$$_ModuleTypeCopyWith<$Res> {
  __$$_ModuleTypeCopyWithImpl(
      _$_ModuleType _value, $Res Function(_$_ModuleType) _then)
      : super(_value, (v) => _then(v as _$_ModuleType));

  @override
  _$_ModuleType get _value => super._value as _$_ModuleType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_ModuleType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ModuleType extends _ModuleType {
  const _$_ModuleType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'ModuleType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ModuleType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_ModuleTypeCopyWith<_$_ModuleType> get copyWith =>
      __$$_ModuleTypeCopyWithImpl<_$_ModuleType>(this, _$identity);
}

abstract class _ModuleType extends ModuleType {
  const factory _ModuleType(final String value) = _$_ModuleType;
  const _ModuleType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ModuleTypeCopyWith<_$_ModuleType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ResponseStatus {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ResponseStatusCopyWith<ResponseStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseStatusCopyWith<$Res> {
  factory $ResponseStatusCopyWith(
          ResponseStatus value, $Res Function(ResponseStatus) then) =
      _$ResponseStatusCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$ResponseStatusCopyWithImpl<$Res>
    implements $ResponseStatusCopyWith<$Res> {
  _$ResponseStatusCopyWithImpl(this._value, this._then);

  final ResponseStatus _value;
  // ignore: unused_field
  final $Res Function(ResponseStatus) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_ResponseStatusCopyWith<$Res>
    implements $ResponseStatusCopyWith<$Res> {
  factory _$$_ResponseStatusCopyWith(
          _$_ResponseStatus value, $Res Function(_$_ResponseStatus) then) =
      __$$_ResponseStatusCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_ResponseStatusCopyWithImpl<$Res>
    extends _$ResponseStatusCopyWithImpl<$Res>
    implements _$$_ResponseStatusCopyWith<$Res> {
  __$$_ResponseStatusCopyWithImpl(
      _$_ResponseStatus _value, $Res Function(_$_ResponseStatus) _then)
      : super(_value, (v) => _then(v as _$_ResponseStatus));

  @override
  _$_ResponseStatus get _value => super._value as _$_ResponseStatus;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_ResponseStatus(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ResponseStatus extends _ResponseStatus {
  const _$_ResponseStatus(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'ResponseStatus(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResponseStatus &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_ResponseStatusCopyWith<_$_ResponseStatus> get copyWith =>
      __$$_ResponseStatusCopyWithImpl<_$_ResponseStatus>(this, _$identity);
}

abstract class _ResponseStatus extends ResponseStatus {
  const factory _ResponseStatus(final String value) = _$_ResponseStatus;
  const _ResponseStatus._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ResponseStatusCopyWith<_$_ResponseStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DeviceTimeStamp {
  DateTime get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeviceTimeStampCopyWith<DeviceTimeStamp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceTimeStampCopyWith<$Res> {
  factory $DeviceTimeStampCopyWith(
          DeviceTimeStamp value, $Res Function(DeviceTimeStamp) then) =
      _$DeviceTimeStampCopyWithImpl<$Res>;
  $Res call({DateTime value});
}

/// @nodoc
class _$DeviceTimeStampCopyWithImpl<$Res>
    implements $DeviceTimeStampCopyWith<$Res> {
  _$DeviceTimeStampCopyWithImpl(this._value, this._then);

  final DeviceTimeStamp _value;
  // ignore: unused_field
  final $Res Function(DeviceTimeStamp) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$$_DeviceTimeStampCopyWith<$Res>
    implements $DeviceTimeStampCopyWith<$Res> {
  factory _$$_DeviceTimeStampCopyWith(
          _$_DeviceTimeStamp value, $Res Function(_$_DeviceTimeStamp) then) =
      __$$_DeviceTimeStampCopyWithImpl<$Res>;
  @override
  $Res call({DateTime value});
}

/// @nodoc
class __$$_DeviceTimeStampCopyWithImpl<$Res>
    extends _$DeviceTimeStampCopyWithImpl<$Res>
    implements _$$_DeviceTimeStampCopyWith<$Res> {
  __$$_DeviceTimeStampCopyWithImpl(
      _$_DeviceTimeStamp _value, $Res Function(_$_DeviceTimeStamp) _then)
      : super(_value, (v) => _then(v as _$_DeviceTimeStamp));

  @override
  _$_DeviceTimeStamp get _value => super._value as _$_DeviceTimeStamp;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_DeviceTimeStamp(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$_DeviceTimeStamp extends _DeviceTimeStamp {
  const _$_DeviceTimeStamp(this.value) : super._();

  @override
  final DateTime value;

  @override
  String toString() {
    return 'DeviceTimeStamp(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DeviceTimeStamp &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_DeviceTimeStampCopyWith<_$_DeviceTimeStamp> get copyWith =>
      __$$_DeviceTimeStampCopyWithImpl<_$_DeviceTimeStamp>(this, _$identity);
}

abstract class _DeviceTimeStamp extends DeviceTimeStamp {
  const factory _DeviceTimeStamp(final DateTime value) = _$_DeviceTimeStamp;
  const _DeviceTimeStamp._() : super._();

  @override
  DateTime get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_DeviceTimeStampCopyWith<_$_DeviceTimeStamp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DialogType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DialogTypeCopyWith<DialogType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DialogTypeCopyWith<$Res> {
  factory $DialogTypeCopyWith(
          DialogType value, $Res Function(DialogType) then) =
      _$DialogTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$DialogTypeCopyWithImpl<$Res> implements $DialogTypeCopyWith<$Res> {
  _$DialogTypeCopyWithImpl(this._value, this._then);

  final DialogType _value;
  // ignore: unused_field
  final $Res Function(DialogType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_DialogTypeCopyWith<$Res>
    implements $DialogTypeCopyWith<$Res> {
  factory _$$_DialogTypeCopyWith(
          _$_DialogType value, $Res Function(_$_DialogType) then) =
      __$$_DialogTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_DialogTypeCopyWithImpl<$Res> extends _$DialogTypeCopyWithImpl<$Res>
    implements _$$_DialogTypeCopyWith<$Res> {
  __$$_DialogTypeCopyWithImpl(
      _$_DialogType _value, $Res Function(_$_DialogType) _then)
      : super(_value, (v) => _then(v as _$_DialogType));

  @override
  _$_DialogType get _value => super._value as _$_DialogType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_DialogType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_DialogType extends _DialogType {
  const _$_DialogType(this.value) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'DialogType(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DialogType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_DialogTypeCopyWith<_$_DialogType> get copyWith =>
      __$$_DialogTypeCopyWithImpl<_$_DialogType>(this, _$identity);
}

abstract class _DialogType extends DialogType {
  const factory _DialogType(final String value) = _$_DialogType;
  const _DialogType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_DialogTypeCopyWith<_$_DialogType> get copyWith =>
      throw _privateConstructorUsedError;
}
