// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'value_objects.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UniqueId {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UniqueIdCopyWith<UniqueId> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UniqueIdCopyWith<$Res> {
  factory $UniqueIdCopyWith(UniqueId value, $Res Function(UniqueId) then) =
      _$UniqueIdCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$UniqueIdCopyWithImpl<$Res> implements $UniqueIdCopyWith<$Res> {
  _$UniqueIdCopyWithImpl(this._value, this._then);

  final UniqueId _value;
  // ignore: unused_field
  final $Res Function(UniqueId) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_UniqueIdCopyWith<$Res> implements $UniqueIdCopyWith<$Res> {
  factory _$$_UniqueIdCopyWith(
          _$_UniqueId value, $Res Function(_$_UniqueId) then) =
      __$$_UniqueIdCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_UniqueIdCopyWithImpl<$Res> extends _$UniqueIdCopyWithImpl<$Res>
    implements _$$_UniqueIdCopyWith<$Res> {
  __$$_UniqueIdCopyWithImpl(
      _$_UniqueId _value, $Res Function(_$_UniqueId) _then)
      : super(_value, (v) => _then(v as _$_UniqueId));

  @override
  _$_UniqueId get _value => super._value as _$_UniqueId;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_UniqueId(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_UniqueId extends _UniqueId with DiagnosticableTreeMixin {
  const _$_UniqueId(this.value) : super._();

  @override
  final String value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UniqueId(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UniqueId'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniqueId &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_UniqueIdCopyWith<_$_UniqueId> get copyWith =>
      __$$_UniqueIdCopyWithImpl<_$_UniqueId>(this, _$identity);
}

abstract class _UniqueId extends UniqueId {
  const factory _UniqueId(final String value) = _$_UniqueId;
  const _UniqueId._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_UniqueIdCopyWith<_$_UniqueId> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LoadState {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LoadStateCopyWith<LoadState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoadStateCopyWith<$Res> {
  factory $LoadStateCopyWith(LoadState value, $Res Function(LoadState) then) =
      _$LoadStateCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$LoadStateCopyWithImpl<$Res> implements $LoadStateCopyWith<$Res> {
  _$LoadStateCopyWithImpl(this._value, this._then);

  final LoadState _value;
  // ignore: unused_field
  final $Res Function(LoadState) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_LoadStateCopyWith<$Res> implements $LoadStateCopyWith<$Res> {
  factory _$$_LoadStateCopyWith(
          _$_LoadState value, $Res Function(_$_LoadState) then) =
      __$$_LoadStateCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_LoadStateCopyWithImpl<$Res> extends _$LoadStateCopyWithImpl<$Res>
    implements _$$_LoadStateCopyWith<$Res> {
  __$$_LoadStateCopyWithImpl(
      _$_LoadState _value, $Res Function(_$_LoadState) _then)
      : super(_value, (v) => _then(v as _$_LoadState));

  @override
  _$_LoadState get _value => super._value as _$_LoadState;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_LoadState(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_LoadState extends _LoadState with DiagnosticableTreeMixin {
  const _$_LoadState(this.value) : super._();

  @override
  final String value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoadState(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoadState'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoadState &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_LoadStateCopyWith<_$_LoadState> get copyWith =>
      __$$_LoadStateCopyWithImpl<_$_LoadState>(this, _$identity);
}

abstract class _LoadState extends LoadState {
  const factory _LoadState(final String value) = _$_LoadState;
  const _LoadState._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_LoadStateCopyWith<_$_LoadState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PageState {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PageStateCopyWith<PageState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageStateCopyWith<$Res> {
  factory $PageStateCopyWith(PageState value, $Res Function(PageState) then) =
      _$PageStateCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$PageStateCopyWithImpl<$Res> implements $PageStateCopyWith<$Res> {
  _$PageStateCopyWithImpl(this._value, this._then);

  final PageState _value;
  // ignore: unused_field
  final $Res Function(PageState) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_PageStateCopyWith<$Res> implements $PageStateCopyWith<$Res> {
  factory _$$_PageStateCopyWith(
          _$_PageState value, $Res Function(_$_PageState) then) =
      __$$_PageStateCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_PageStateCopyWithImpl<$Res> extends _$PageStateCopyWithImpl<$Res>
    implements _$$_PageStateCopyWith<$Res> {
  __$$_PageStateCopyWithImpl(
      _$_PageState _value, $Res Function(_$_PageState) _then)
      : super(_value, (v) => _then(v as _$_PageState));

  @override
  _$_PageState get _value => super._value as _$_PageState;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_PageState(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_PageState extends _PageState with DiagnosticableTreeMixin {
  const _$_PageState(this.value) : super._();

  @override
  final String value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PageState(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PageState'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PageState &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_PageStateCopyWith<_$_PageState> get copyWith =>
      __$$_PageStateCopyWithImpl<_$_PageState>(this, _$identity);
}

abstract class _PageState extends PageState {
  const factory _PageState(final String value) = _$_PageState;
  const _PageState._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_PageStateCopyWith<_$_PageState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NavigationPage {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NavigationPageCopyWith<NavigationPage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NavigationPageCopyWith<$Res> {
  factory $NavigationPageCopyWith(
          NavigationPage value, $Res Function(NavigationPage) then) =
      _$NavigationPageCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$NavigationPageCopyWithImpl<$Res>
    implements $NavigationPageCopyWith<$Res> {
  _$NavigationPageCopyWithImpl(this._value, this._then);

  final NavigationPage _value;
  // ignore: unused_field
  final $Res Function(NavigationPage) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_NavigationPageCopyWith<$Res>
    implements $NavigationPageCopyWith<$Res> {
  factory _$$_NavigationPageCopyWith(
          _$_NavigationPage value, $Res Function(_$_NavigationPage) then) =
      __$$_NavigationPageCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_NavigationPageCopyWithImpl<$Res>
    extends _$NavigationPageCopyWithImpl<$Res>
    implements _$$_NavigationPageCopyWith<$Res> {
  __$$_NavigationPageCopyWithImpl(
      _$_NavigationPage _value, $Res Function(_$_NavigationPage) _then)
      : super(_value, (v) => _then(v as _$_NavigationPage));

  @override
  _$_NavigationPage get _value => super._value as _$_NavigationPage;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_NavigationPage(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_NavigationPage extends _NavigationPage with DiagnosticableTreeMixin {
  const _$_NavigationPage(this.value) : super._();

  @override
  final String value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NavigationPage(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'NavigationPage'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NavigationPage &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_NavigationPageCopyWith<_$_NavigationPage> get copyWith =>
      __$$_NavigationPageCopyWithImpl<_$_NavigationPage>(this, _$identity);
}

abstract class _NavigationPage extends NavigationPage {
  const factory _NavigationPage(final String value) = _$_NavigationPage;
  const _NavigationPage._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_NavigationPageCopyWith<_$_NavigationPage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NetworkType {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NetworkTypeCopyWith<NetworkType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NetworkTypeCopyWith<$Res> {
  factory $NetworkTypeCopyWith(
          NetworkType value, $Res Function(NetworkType) then) =
      _$NetworkTypeCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$NetworkTypeCopyWithImpl<$Res> implements $NetworkTypeCopyWith<$Res> {
  _$NetworkTypeCopyWithImpl(this._value, this._then);

  final NetworkType _value;
  // ignore: unused_field
  final $Res Function(NetworkType) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_NetworkTypeCopyWith<$Res>
    implements $NetworkTypeCopyWith<$Res> {
  factory _$$_NetworkTypeCopyWith(
          _$_NetworkType value, $Res Function(_$_NetworkType) then) =
      __$$_NetworkTypeCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_NetworkTypeCopyWithImpl<$Res> extends _$NetworkTypeCopyWithImpl<$Res>
    implements _$$_NetworkTypeCopyWith<$Res> {
  __$$_NetworkTypeCopyWithImpl(
      _$_NetworkType _value, $Res Function(_$_NetworkType) _then)
      : super(_value, (v) => _then(v as _$_NetworkType));

  @override
  _$_NetworkType get _value => super._value as _$_NetworkType;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_NetworkType(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_NetworkType extends _NetworkType with DiagnosticableTreeMixin {
  const _$_NetworkType(this.value) : super._();

  @override
  final String value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkType(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'NetworkType'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NetworkType &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_NetworkTypeCopyWith<_$_NetworkType> get copyWith =>
      __$$_NetworkTypeCopyWithImpl<_$_NetworkType>(this, _$identity);
}

abstract class _NetworkType extends NetworkType {
  const factory _NetworkType(final String value) = _$_NetworkType;
  const _NetworkType._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_NetworkTypeCopyWith<_$_NetworkType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SyncState {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SyncStateCopyWith<SyncState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SyncStateCopyWith<$Res> {
  factory $SyncStateCopyWith(SyncState value, $Res Function(SyncState) then) =
      _$SyncStateCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$SyncStateCopyWithImpl<$Res> implements $SyncStateCopyWith<$Res> {
  _$SyncStateCopyWithImpl(this._value, this._then);

  final SyncState _value;
  // ignore: unused_field
  final $Res Function(SyncState) _then;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_SyncStateCopyWith<$Res> implements $SyncStateCopyWith<$Res> {
  factory _$$_SyncStateCopyWith(
          _$_SyncState value, $Res Function(_$_SyncState) then) =
      __$$_SyncStateCopyWithImpl<$Res>;
  @override
  $Res call({String value});
}

/// @nodoc
class __$$_SyncStateCopyWithImpl<$Res> extends _$SyncStateCopyWithImpl<$Res>
    implements _$$_SyncStateCopyWith<$Res> {
  __$$_SyncStateCopyWithImpl(
      _$_SyncState _value, $Res Function(_$_SyncState) _then)
      : super(_value, (v) => _then(v as _$_SyncState));

  @override
  _$_SyncState get _value => super._value as _$_SyncState;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_SyncState(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SyncState extends _SyncState with DiagnosticableTreeMixin {
  const _$_SyncState(this.value) : super._();

  @override
  final String value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SyncState(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SyncState'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SyncState &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$_SyncStateCopyWith<_$_SyncState> get copyWith =>
      __$$_SyncStateCopyWithImpl<_$_SyncState>(this, _$identity);
}

abstract class _SyncState extends SyncState {
  const factory _SyncState(final String value) = _$_SyncState;
  const _SyncState._() : super._();

  @override
  String get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_SyncStateCopyWith<_$_SyncState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DtoInfo {
  String? get box => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;
  bool get readOnly => throw _privateConstructorUsedError;
  bool get isMapEntries => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DtoInfoCopyWith<DtoInfo> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DtoInfoCopyWith<$Res> {
  factory $DtoInfoCopyWith(DtoInfo value, $Res Function(DtoInfo) then) =
      _$DtoInfoCopyWithImpl<$Res>;
  $Res call({String? box, String? key, bool readOnly, bool isMapEntries});
}

/// @nodoc
class _$DtoInfoCopyWithImpl<$Res> implements $DtoInfoCopyWith<$Res> {
  _$DtoInfoCopyWithImpl(this._value, this._then);

  final DtoInfo _value;
  // ignore: unused_field
  final $Res Function(DtoInfo) _then;

  @override
  $Res call({
    Object? box = freezed,
    Object? key = freezed,
    Object? readOnly = freezed,
    Object? isMapEntries = freezed,
  }) {
    return _then(_value.copyWith(
      box: box == freezed
          ? _value.box
          : box // ignore: cast_nullable_to_non_nullable
              as String?,
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      readOnly: readOnly == freezed
          ? _value.readOnly
          : readOnly // ignore: cast_nullable_to_non_nullable
              as bool,
      isMapEntries: isMapEntries == freezed
          ? _value.isMapEntries
          : isMapEntries // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_DtoInfoCopyWith<$Res> implements $DtoInfoCopyWith<$Res> {
  factory _$$_DtoInfoCopyWith(
          _$_DtoInfo value, $Res Function(_$_DtoInfo) then) =
      __$$_DtoInfoCopyWithImpl<$Res>;
  @override
  $Res call({String? box, String? key, bool readOnly, bool isMapEntries});
}

/// @nodoc
class __$$_DtoInfoCopyWithImpl<$Res> extends _$DtoInfoCopyWithImpl<$Res>
    implements _$$_DtoInfoCopyWith<$Res> {
  __$$_DtoInfoCopyWithImpl(_$_DtoInfo _value, $Res Function(_$_DtoInfo) _then)
      : super(_value, (v) => _then(v as _$_DtoInfo));

  @override
  _$_DtoInfo get _value => super._value as _$_DtoInfo;

  @override
  $Res call({
    Object? box = freezed,
    Object? key = freezed,
    Object? readOnly = freezed,
    Object? isMapEntries = freezed,
  }) {
    return _then(_$_DtoInfo(
      box: box == freezed
          ? _value.box
          : box // ignore: cast_nullable_to_non_nullable
              as String?,
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      readOnly: readOnly == freezed
          ? _value.readOnly
          : readOnly // ignore: cast_nullable_to_non_nullable
              as bool,
      isMapEntries: isMapEntries == freezed
          ? _value.isMapEntries
          : isMapEntries // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_DtoInfo extends _DtoInfo with DiagnosticableTreeMixin {
  const _$_DtoInfo(
      {this.box, this.key, this.readOnly = false, this.isMapEntries = false})
      : super._();

  @override
  final String? box;
  @override
  final String? key;
  @override
  @JsonKey()
  final bool readOnly;
  @override
  @JsonKey()
  final bool isMapEntries;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DtoInfo(box: $box, key: $key, readOnly: $readOnly, isMapEntries: $isMapEntries)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DtoInfo'))
      ..add(DiagnosticsProperty('box', box))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('readOnly', readOnly))
      ..add(DiagnosticsProperty('isMapEntries', isMapEntries));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DtoInfo &&
            const DeepCollectionEquality().equals(other.box, box) &&
            const DeepCollectionEquality().equals(other.key, key) &&
            const DeepCollectionEquality().equals(other.readOnly, readOnly) &&
            const DeepCollectionEquality()
                .equals(other.isMapEntries, isMapEntries));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(box),
      const DeepCollectionEquality().hash(key),
      const DeepCollectionEquality().hash(readOnly),
      const DeepCollectionEquality().hash(isMapEntries));

  @JsonKey(ignore: true)
  @override
  _$$_DtoInfoCopyWith<_$_DtoInfo> get copyWith =>
      __$$_DtoInfoCopyWithImpl<_$_DtoInfo>(this, _$identity);
}

abstract class _DtoInfo extends DtoInfo {
  const factory _DtoInfo(
      {final String? box,
      final String? key,
      final bool readOnly,
      final bool isMapEntries}) = _$_DtoInfo;
  const _DtoInfo._() : super._();

  @override
  String? get box => throw _privateConstructorUsedError;
  @override
  String? get key => throw _privateConstructorUsedError;
  @override
  bool get readOnly => throw _privateConstructorUsedError;
  @override
  bool get isMapEntries => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_DtoInfoCopyWith<_$_DtoInfo> get copyWith =>
      throw _privateConstructorUsedError;
}
